input ActivitiesRequest {
  query: ActivitiesRequestQuery!
  user: EvmAddress
  types: [ActivityType!]! = [BORROW, SUPPLY, WITHDRAW, REPAY, LIQUIDATED, SET_AS_COLLATERAL, UPDATED_DYNAMIC_CONFIG, UPDATED_RISK_PREMIUM]
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

input ActivitiesRequestQuery @oneOf {
  hub: HubInput
  hubId: HubId
  spoke: SpokeInput
  spokeId: SpokeId
  chainIds: [ChainId!]
  txHash: TxHashInput
  userPositionId: UserPositionId
}

union ActivityItem = BorrowActivity | SupplyActivity | WithdrawActivity | RepayActivity | LiquidatedActivity | UsingAsCollateralActivity | UpdatedDynamicConfigActivity | UpdatedRiskPremiumActivity

enum ActivityType {
  SUPPLY
  BORROW
  REPAY
  WITHDRAW
  LIQUIDATED
  SET_AS_COLLATERAL
  UPDATED_DYNAMIC_CONFIG
  UPDATED_RISK_PREMIUM
}

scalar AlwaysTrue

input AmountInput @oneOf {
  """Exact amount"""
  exact: BigDecimal

  """Max amount"""
  max: AlwaysTrue
}

enum ApyMetric {
  HIGHEST
  LOWEST
  AVERAGE
}

type ApySample {
  date: DateTime!
  avgRate: PercentNumber!
}

type Asset {
  id: AssetId!
  token: Erc20Token!
  summary: AssetSummary!
  price(currency: Currency! = USD): ExchangeAmountWithChange!
}

type AssetAmountWithChange {
  amount: DecimalNumberWithChange!
  exchange(currency: Currency! = USD): ExchangeAmountWithChange!
}

input AssetBorrowHistoryRequest {
  query: AssetBorrowHistoryRequestQuery!
  window: TimeWindow! = LAST_DAY
}

input AssetBorrowHistoryRequestQuery @oneOf {
  token: Erc20Input
  assetId: AssetId
}

type AssetBorrowSample {
  date: DateTime!
  amount: DecimalNumber!
  highestApy: PercentNumber!
  lowestApy: PercentNumber!
}

scalar AssetId

input AssetPriceHistoryRequest {
  query: AssetPriceHistoryRequestQuery!
  currency: Currency! = USD
  window: TimeWindow! = LAST_DAY
}

input AssetPriceHistoryRequestQuery @oneOf {
  token: Erc20Input
  assetId: AssetId
}

type AssetPriceSample {
  date: DateTime!
  price: BigDecimal!
}

input AssetRequest {
  query: AssetRequestQuery!
}

input AssetRequestQuery @oneOf {
  token: Erc20Input
  assetId: AssetId
}

type AssetSummary {
  totalSupplyCap: AssetAmountWithChange!
  totalSupplied: AssetAmountWithChange!
  totalSuppliable: AssetAmountWithChange!
  totalBorrowCap: AssetAmountWithChange!
  totalBorrowed: AssetAmountWithChange!
  totalBorrowable: AssetAmountWithChange!

  """The supply apy dependent on what you pass in for the `metric`"""
  supplyApy(metric: ApyMetric! = AVERAGE): PercentNumber!

  """The borrow APY dependent on what you pass in for the `metric`"""
  borrowApy(metric: ApyMetric! = AVERAGE): PercentNumber!
}

input AssetSupplyHistoryRequest {
  query: AssetSupplyHistoryRequestQuery!
  window: TimeWindow! = LAST_DAY
}

input AssetSupplyHistoryRequestQuery @oneOf {
  token: Erc20Input
  assetId: AssetId
}

type AssetSupplySample {
  date: DateTime!
  amount: DecimalNumber!
  highestApy: PercentNumber!
  lowestApy: PercentNumber!
}

scalar BigDecimal

scalar BigInt

scalar BlockchainData

type BorrowActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  borrowed: Erc20Amount!
  chain: Chain!
}

input BorrowApyHistoryRequest {
  reserve: ReserveId!
  window: TimeWindow! = LAST_DAY
}

input BorrowRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount supplying"""
  amount: ReserveAmountInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

enum BorrowSwapKind {
  CURRENT
  NEW
}

input BorrowSwapQuoteRequest @oneOf {
  market: MarketDebtSwapQuoteInput
  limit: LimitDebtSwapQuoteInput
  fromQuote: FromQuoteDebtSwapQuoteInput
}

union BorrowSwapQuoteResult = PositionSwapByIntentApprovalsRequired

input CancelIntentSwapInput {
  id: SwapId!
  signature: Signature!
}

union CancelSwapExecutionPlan = TransactionRequest | SwapCancelled

input CancelSwapRequest @oneOf {
  intent: CancelIntentSwapInput
  transaction: SwapId
}

type Chain {
  name: String!
  icon: String!
  chainId: ChainId!
  explorerUrl: String!
  isTestnet: Boolean!
  nativeWrappedToken: EvmAddress!
  nativeInfo: TokenInfo!
  nativeGateway: EvmAddress!
  signatureGateway: EvmAddress!
  rpcUrl: String!
  isFork: Boolean!
}

"""A supported blockchain chain ID"""
scalar ChainId

input ChainRequest {
  """The chain id"""
  chainId: ChainId!
}

input ChainTokenCategories {
  chainId: ChainId!
  categories: [TokenCategory!]!
}

input ChainTokenInput {
  """The chain id"""
  chainId: ChainId!

  """The token input"""
  token: TokenInput!
}

enum ChainsFilter {
  TESTNET_ONLY
  MAINNET_ONLY
  ALL
}

input ChainsRequest {
  query: ChainsRequestQuery!
}

input ChainsRequestQuery @oneOf {
  chainIds: [ChainId!]
  filter: ChainsFilter
}

type CollateralFactorVariation {
  reserveId: ReserveId!
  token: Erc20Token!
  current: PercentNumber!
  after: PercentNumber!
}

enum CollateralMetric {
  HIGHEST
  LOWEST
}

enum Currency {
  USD
  GBP
  EUR
}

scalar Cursor

scalar DateTime

type DecimalNumber {
  """The on-chain representation of `value`, stored as an integer."""
  onChainValue: BigInt!

  """
  The number of decimals defining how many fractional digits the number supports.
  """
  decimals: Int!

  """The normalized value computed as `onChainValue / 10^decimals`."""
  value: BigDecimal!
}

type DecimalNumberWithChange {
  current: DecimalNumber!
  change(window: TimeWindow! = LAST_DAY): PercentNumber!
}

type DomainData {
  name: String!
  version: String!
  chainId: ChainId!
  verifyingContract: EvmAddress!
}

"""A dynamic reserve configuration key"""
scalar DynamicConfigKey

input ERC20PermitSignature {
  """The signature for the erc721"""
  value: Signature!

  """The deadline for the erc721"""
  deadline: Int!
}

type Erc20Amount {
  """The value"""
  amount: DecimalNumber!

  """The exchange amount"""
  exchange(currency: Currency! = USD): ExchangeAmount!

  """The exchange rate"""
  exchangeRate(currency: Currency! = USD): DecimalNumber!
  isWrappedNative: Boolean!
  token: Erc20Token!
}

type Erc20Approval {
  """Transaction request for the approval"""
  byTransaction: TransactionRequest!

  """
  Typed data response for the permit signature (if available for the given token)
  """
  bySignature: PermitTypedDataResponse
}

type Erc20ApprovalRequired {
  """The transaction requires an approval first"""
  transaction: TransactionRequest!

  """The reason for the approval"""
  reason: String!

  """The required amount missing to be able to do the original transaction"""
  requiredAmount: DecimalNumber!

  """The current allowance approved"""
  currentAllowance: DecimalNumber!

  """The transaction to send after the approval is complete"""
  originalTransaction: TransactionRequest!
}

input Erc20Input {
  """The token address"""
  address: EvmAddress!

  """The token chain id"""
  chainId: ChainId!
}

type Erc20Token {
  """The token address"""
  address: EvmAddress!

  """The chain its deployed to"""
  chain: Chain!

  """The ERC20 token info"""
  info: TokenInfo!

  """
  The protocol only deals with ERC20 this allows you to understand if
  the token is a wrapped native token to allow you to maybe change `WETH` > `ETH`
  on the display screen, or whatever you decide makes sense
  """
  isWrappedNativeToken: Boolean!

  """If permit is supported for the ERC20 token"""
  permitSupported: Boolean!
}

scalar EvmAddress

type ExchangeAmount {
  value: BigDecimal!
  name: String!
  symbol: String!
  icon: String!
  decimals: Int!
}

type ExchangeAmountVariation {
  current: ExchangeAmount!
  after: ExchangeAmount!
}

type ExchangeAmountWithChange {
  current: ExchangeAmount!
  change(window: TimeWindow! = LAST_DAY): PercentNumber!
}

input ExchangeRateRequest {
  """The from criteria"""
  from: ExchangeRateRequestFrom!

  """The currency to get the result in"""
  to: Currency!

  """
  The date time to get the exchange rate at, if not provided the latest rate is returned
  """
  at: DateTime
}

input ExchangeRateRequestFrom @oneOf {
  """The currency"""
  fiat: Currency

  """The erc20 token"""
  erc20: Erc20Input

  """The native token"""
  native: ChainId
}

union ExecutionPlan = TransactionRequest | Erc20ApprovalRequired | PreContractActionRequired | InsufficientBalanceError

input ForkTopUpErc20 {
  """The token address"""
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction
  """
  value: BigDecimal!
}

input ForkTopUpRequest {
  """The address you want the funds to be topped up against"""
  user: EvmAddress!

  """The erc20 information"""
  erc20: ForkTopUpErc20

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction
  """
  native: BigDecimal
}

type ForkTopUpResponse {
  message: String!

  """The tx hash of the newly created transaction"""
  txHash: String
}

input FromQuoteDebtSwapQuoteInput {
  quoteId: SwapQuoteId!
  newSlippage: BigDecimal
}

input FromQuoteRepayWithSupplyQuoteInput {
  quoteId: SwapQuoteId!
  newSlippage: BigDecimal
}

input FromQuoteSupplySwapQuoteInput {
  quoteId: SwapQuoteId!
  newSlippage: BigDecimal
}

input FromQuoteWithdrawSwapQuoteInput {
  quoteId: SwapQuoteId!
  newSlippage: BigDecimal
}

input HasProcessedKnownTransactionRequest {
  """
  The operation types this is given to you on the TransactionRequest::operations
  """
  operations: [OperationType!]!

  """The tx hash"""
  txHash: TxHash!
}

type HealthFactorError {
  reason: String!
  current: BigDecimal
  after: BigDecimal
}

union HealthFactorResult = HealthFactorVariation | HealthFactorError

type HealthFactorVariation {
  current: BigDecimal
  after: BigDecimal
}

type HealthFactorWithChange {
  current: BigDecimal
  change(window: TimeWindow! = LAST_DAY): PercentNumber!
}

type Hub {
  """The id for the hub"""
  id: HubId!

  """The hub name"""
  name: String!

  """The hub address"""
  address: EvmAddress!

  """The chain the hub is deployed on"""
  chain: Chain!

  """The hub summary"""
  summary(currency: Currency! = USD): HubSummary!
}

type HubAsset {
  """The id for the hub asset"""
  id: HubAssetId!

  """The onchain asset id"""
  onchainAssetId: OnChainHubAssetId!

  """The hub"""
  hub: Hub!

  """The underlying token"""
  underlying: Erc20Token!

  """The hub asset summary"""
  summary: HubAssetSummary!

  """The hub asset settings"""
  settings: HubAssetSettings!
  userState: HubAssetUserState
}

scalar HubAssetId

type HubAssetSettings {
  """The fee receiver"""
  feeReceiver: EvmAddress!

  """The liquidity fee"""
  liquidityFee: PercentNumber!

  """The ir strategy"""
  irStrategy: EvmAddress!

  """The reinvestment strategy"""
  reinvestmentController: EvmAddress
}

type HubAssetSummary {
  """The supplied amount"""
  supplied: Erc20Amount!

  """The borrowed amount"""
  borrowed: Erc20Amount!

  """The available liquidity"""
  availableLiquidity: Erc20Amount!

  """The supply apy"""
  supplyApy: PercentNumber!

  """The borrow apy"""
  borrowApy: PercentNumber!

  """The net apy"""
  netApy: PercentNumber!

  """The utilization rate"""
  utilizationRate: PercentNumber!
}

type HubAssetUserState {
  """The hub asset balance"""
  balance: Erc20Amount!
}

input HubAssetsRequest {
  query: HubAssetsRequestQuery!
  user: EvmAddress
  orderBy: HubAssetsRequestOrderBy! = {assetName: ASC}
}

input HubAssetsRequestOrderBy @oneOf {
  assetName: OrderDirection
  availableLiquidity: OrderDirection
  supplyApy: OrderDirection
  borrowApy: OrderDirection
}

input HubAssetsRequestQuery @oneOf {
  hubInput: HubInput
  hubId: HubId
}

scalar HubId

input HubIdTokenInput {
  hubId: HubId!
  token: EvmAddress!
}

input HubInput {
  """The hub address"""
  address: EvmAddress!

  """The hub chain id"""
  chainId: ChainId!
}

input HubRequest {
  query: HubRequestQuery!
}

input HubRequestQuery @oneOf {
  hubInput: HubInput
  hubId: HubId
}

type HubSummary {
  """
  The total spoke reserves aggregated borrowed using this hub, showed in exchange amount as each asset has a different value
  """
  totalBorrowed: ExchangeAmountWithChange!

  """
  The total spoke reserves aggregated borrow caps using this hub, showed in exchange amount as each asset has a different value
  """
  totalBorrowCap: ExchangeAmount!

  """
  The total spoke reserves aggregated supplied using this hub, showed in exchange amount as each asset has a different value
  """
  totalSupplied: ExchangeAmountWithChange!

  """
  The total spoke reserves aggregated supply caps using this hub, showed in exchange amount as each asset has a different value
  """
  totalSupplyCap: ExchangeAmount!

  """The utilization rate"""
  utilizationRate: PercentNumber!
}

input HubSummaryHistoryRequest {
  query: HubSummaryHistoryRequestQuery!
  currency: Currency! = USD
  window: TimeWindow! = LAST_DAY
}

input HubSummaryHistoryRequestQuery @oneOf {
  hubInput: HubInput
  hubId: HubId
}

type HubSummarySample {
  date: DateTime!
  deposits: ExchangeAmount!
  borrows: ExchangeAmount!
  availableLiquidity: ExchangeAmount!
  utilizationRate: PercentNumber!
}

input HubTokenInput {
  chainId: ChainId!
  hub: EvmAddress!
  token: EvmAddress!
}

input HubsRequest {
  query: HubsRequestQuery!
  orderBy: HubsRequestOrderBy! = {name: ASC}
}

input HubsRequestOrderBy @oneOf {
  name: OrderDirection
  totalBorrowed: OrderDirection
  totalSupplied: OrderDirection
}

input HubsRequestQuery @oneOf {
  """Get back all the hubs which have one of the underlying tokens supplied"""
  tokens: [Erc20Input!]

  """Get back all the hubs based on the chain ids passed in"""
  chainIds: [ChainId!]
}

type InsufficientBalanceError {
  """The amount required to do the original transaction"""
  required: DecimalNumber!

  """The amount available in the wallet"""
  available: DecimalNumber!
}

"""A scalar that can represent any JSON value."""
scalar JSON

input LimitDebtSwapQuoteInput {
  quoteId: SwapQuoteId
  currentPosition: UserBorrowItemId!
  currentAmount: BigDecimal!
  newReserve: ReserveId!
  newAmount: BigDecimal!
  user: EvmAddress!
  kind: BorrowSwapKind
}

input LimitOrderTokenSwapQuoteInput {
  """
  Quote accuracy level - FAST for faster response, ACCURATE for verified pricing (default)
  """
  accuracy: QuoteAccuracy! = ACCURATE
  chainId: ChainId!
  sell: SwapTokenInput!
  buy: SwapTokenInput!
  user: EvmAddress!
  receiver: EvmAddress
  kind: SwapKind! = SELL
  previousQuoteId: SwapQuoteId
}

input LimitRepayWithSupplyQuoteInput {
  quoteId: SwapQuoteId
  repayPosition: UserBorrowItemId!
  repayAmount: BigDecimal!
  supplyPosition: UserSupplyItemId!
  supplyAmount: BigDecimal!
  user: EvmAddress!
  kind: RepayWithSupplyKind
}

input LimitSupplySwapQuoteInput {
  quoteId: SwapQuoteId
  currentPosition: UserSupplyItemId!
  currentAmount: BigDecimal!
  newReserve: ReserveId!
  newAmount: BigDecimal!
  user: EvmAddress!
  kind: SupplySwapKind
  enableCollateral: Boolean!
}

input LimitWithdrawSwapQuoteInput {
  quoteId: SwapQuoteId
  withdrawPosition: UserSupplyItemId!
  withdrawAmount: BigDecimal!
  buyToken: TokenInput!
  buyAmount: BigDecimal!
  user: EvmAddress!
  kind: WithdrawSwapKind
}

input LiquidatePositionDebtAmount @oneOf {
  """Exact amount"""
  exact: BigDecimal

  """The most you can liquidate"""
  max: AlwaysTrue
}

union LiquidatePositionExecutionPlan = TransactionRequest | Erc20ApprovalRequired | InsufficientBalanceError

input LiquidatePositionRequest {
  """The collateral reserve id"""
  collateral: ReserveId!

  """The debt reserve id"""
  debt: ReserveId!

  """The amount to liquidate"""
  amount: LiquidatePositionDebtAmount!

  """The person liquidating the position"""
  liquidator: EvmAddress!

  """The user to liquidate"""
  user: EvmAddress!

  """If you would like to receive shares over the asset"""
  receiveShares: Boolean! = false
}

type LiquidatedActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  collateralReserve: ReserveInfo!
  debtReserve: ReserveInfo!
  collateral: Erc20Amount!
  debt: Erc20Amount!
  liquidator: EvmAddress!
  chain: Chain!
}

type LiquidationFeeVariation {
  reserveId: ReserveId!
  token: Erc20Token!
  current: PercentNumber!
  after: PercentNumber!
}

input MarketDebtSwapQuoteInput {
  """
  Quote accuracy level - FAST for faster response, ACCURATE for verified pricing (default)
  """
  accuracy: QuoteAccuracy! = ACCURATE
  debtPosition: UserBorrowItemId!
  buyReserve: ReserveId!
  amount: BigDecimal!
  user: EvmAddress!
}

input MarketOrderTokenSwapFromQuoteInput {
  quoteId: SwapQuoteId!
  newSlippage: BigDecimal
}

input MarketOrderTokenSwapQuoteInput {
  """
  Quote accuracy level - FAST for faster response, ACCURATE for verified pricing (default)
  """
  accuracy: QuoteAccuracy! = ACCURATE
  chainId: ChainId!
  buy: TokenInput!
  sell: TokenInput!
  amount: BigDecimal!
  kind: SwapKind!
  user: EvmAddress!
  receiver: EvmAddress
}

input MarketRepayWithSupplyQuoteInput {
  """
  Quote accuracy level - FAST for faster response, ACCURATE for verified pricing (default)
  """
  accuracy: QuoteAccuracy! = ACCURATE
  debtPosition: UserBorrowItemId!
  repayWithReserve: ReserveId!
  amount: BigDecimal!
  user: EvmAddress!
}

input MarketSupplySwapQuoteInput {
  """
  Quote accuracy level - FAST for faster response, ACCURATE for verified pricing (default)
  """
  accuracy: QuoteAccuracy! = ACCURATE
  sellPosition: UserSupplyItemId!
  buyReserve: ReserveId!
  amount: BigDecimal!
  user: EvmAddress!
  enableCollateral: Boolean!
}

input MarketWithdrawSwapQuoteInput {
  """
  Quote accuracy level - FAST for faster response, ACCURATE for verified pricing (default)
  """
  accuracy: QuoteAccuracy! = ACCURATE
  position: UserSupplyItemId!
  buyReserve: ReserveId!
  amount: BigDecimal!
  user: EvmAddress!
}

type MaxLiquidationBonusVariation {
  reserveId: ReserveId!
  token: Erc20Token!
  current: PercentNumber!
  after: PercentNumber!
}

type Mutation {
  """Top up a balance for a user or yourself on the fork"""
  forkTopUp(request: ForkTopUpRequest!): ForkTopUpResponse!
  swap(request: SwapRequest!): SwapExecutionPlan!
  cancelSwap(request: CancelSwapRequest!): CancelSwapExecutionPlan!
}

type NativeAmount {
  """The native token"""
  token: NativeToken!

  """The value"""
  amount: DecimalNumber!

  """The exchange amount"""
  exchange(currency: Currency! = USD): ExchangeAmount!

  """The exchange rate"""
  exchangeRate(currency: Currency! = USD): DecimalNumber!
}

type NativeToken {
  info: TokenInfo!
  chain: Chain!
}

scalar OnChainHubAssetId

scalar OnChainReserveId

enum OperationType {
  SPOKE_BORROW
  SPOKE_REPAY
  SPOKE_SUPPLY
  SPOKE_WITHDRAW
  SPOKE_UPDATE_USER_RISK_PREMIUM
  SPOKE_UPDATE_USER_DYNAMIC_CONFIG
  SPOKE_SET_USER_USING_AS_COLLATERAL
  SPOKE_SET_USER_POSITION_MANAGER
  RENOUNCE_SPOKE_USER_POSITION_MANAGER
  LIQUIDATION
}

enum OrderDirection {
  ASC
  DESC
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedActivitiesResult {
  items: [ActivityItem!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedResultInfo {
  """The cursor to the previous page of results, if any."""
  prev: Cursor

  """The cursor to the next page of results, if any."""
  next: Cursor
}

type PaginatedSpokePositionManagerResult {
  items: [SpokePositionManger!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedSpokeUserPositionManagerResult {
  items: [SpokeUserPositionManager!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUserSwapsResult {
  items: [SwapStatus!]!
  pageInfo: PaginatedResultInfo!
}

type PercentNumber {
  """
  The on-chain representation of the percentage, stored in basis points (bps).
  """
  onChainValue: BigInt!

  """The number of decimals defining the precision of `bps`."""
  decimals: Int!

  """The percentage value where 1.0 represents 100%."""
  value: BigDecimal!

  """The human-friendly percentage value formatted for display."""
  normalized: BigDecimal!
}

type PercentNumberChangeSnapshot {
  before: PercentNumber!
  after: PercentNumber!
}

type PercentNumberVariation {
  current: PercentNumber!
  after: PercentNumber!
}

type PercentNumberWithChange {
  current: PercentNumber!
  change(window: TimeWindow! = LAST_DAY): PercentNumber!
}

type PermitMessageData {
  owner: EvmAddress!
  spender: EvmAddress!
  value: BigInt!
  nonce: BigInt!
  deadline: Int!
}

input PermitRequest @oneOf {
  supply: SupplyPermitRequest
  repay: RepayPermitRequest
}

type PermitTypedDataResponse {
  types: TypeDefinition!
  primaryType: String!
  domain: DomainData!
  message: PermitMessageData!
}

type PositionAmount {
  reserve: ReserveInfo
  amount: Erc20Amount!
}

type PositionSwapAdapterContractApproval {
  bySignature: SwapTypedData!
}

union PositionSwapApproval = PositionSwapAdapterContractApproval | PositionSwapPositionManagerApproval

type PositionSwapByIntentApprovalsRequired {
  quote: SwapQuote!
  approvals: [PositionSwapApproval!]!
}

type PositionSwapPositionManagerApproval {
  byTransaction: TransactionRequest!
  bySignature: SwapTypedData!
}

type PreContractActionRequired {
  """The transaction requires a pre-contract action first"""
  transaction: TransactionRequest!

  """The reason for the pre-contract action"""
  reason: String!

  """The transaction to send after the approval is complete"""
  originalTransaction: TransactionRequest!
}

input PreparePositionSwapRequest {
  quoteId: SwapQuoteId!

  """postHook adapter signature - can be approved via transaction"""
  adapterContractSignature: Signature

  """position manager signature - can be approved via transaction"""
  positionManagerSignature: Signature
}

union PreparePositionSwapResult = PrepareSwapOrder | InsufficientBalanceError

input PrepareSwapCancelRequest {
  id: SwapId!
}

type PrepareSwapCancelResult {
  data: SwapTypedData!
}

type PrepareSwapOrder {
  newQuoteId: SwapQuoteId!
  data: SwapTypedData!
}

input PrepareTokenSwapRequest {
  quoteId: SwapQuoteId!
  permitSig: ERC20PermitSignature
}

union PrepareTokenSwapResult = PrepareSwapOrder | InsufficientBalanceError

input PreviewAction @oneOf {
  supply: SupplyRequest
  borrow: BorrowRequest
  repay: RepayRequest
  withdraw: WithdrawRequest
  setUserSuppliesAsCollateral: SetUserSuppliesAsCollateralRequest
  updateUserPositionConditions: UpdateUserPositionConditionsRequest
  supplySwap: SupplySwapQuoteRequest
  borrowSwap: BorrowSwapQuoteRequest
  repayWithSupply: RepayWithSupplyQuoteRequest
  withdrawSwap: WithdrawSwapQuoteRequest
}

input PreviewRequest {
  action: PreviewAction!
}

type PreviewUserPosition {
  id: UserPositionId!
  healthFactor: HealthFactorResult!
  riskPremium: PercentNumberVariation!

  """The net apy for one user position on a current spoke"""
  netApy: PercentNumberVariation!
  netCollateral(currency: Currency! = USD): ExchangeAmountVariation!
  netBalance(currency: Currency! = USD): ExchangeAmountVariation!
  projectedEarnings: ExchangeAmountVariation!
  borrowingPower: ExchangeAmountVariation!
  otherConditions: [UserPositionConditionVariation!]!
}

input ProtocolHistoryRequest {
  currency: Currency! = USD
  window: TimeWindow! = LAST_DAY
}

type ProtocolHistorySample {
  date: DateTime!
  deposits: ExchangeAmount!
  borrows: ExchangeAmount!
}

type Query {
  health: Boolean!
  chain(request: ChainRequest!): Chain
  chains(request: ChainsRequest!): [Chain!]!

  """Generate EIP-712 typed data for EIP-2612 permit signature"""
  permitTypedData(request: PermitRequest!): PermitTypedDataResponse!

  """Get the exchange rate of tokens > currency or currency > currency"""
  exchangeRate(request: ExchangeRateRequest!): ExchangeAmount!
  protocolHistory(request: ProtocolHistoryRequest!): [ProtocolHistorySample!]!
  asset(request: AssetRequest!): Asset
  assetSupplyHistory(request: AssetSupplyHistoryRequest!): [AssetSupplySample!]!
  assetBorrowHistory(request: AssetBorrowHistoryRequest!): [AssetBorrowSample!]!
  assetPriceHistory(request: AssetPriceHistoryRequest!): [AssetPriceSample!]!

  """Fetch a list of hubs depending on your search criteria"""
  hubs(request: HubsRequest!): [Hub!]!
  hub(request: HubRequest!): Hub
  hubAssets(request: HubAssetsRequest!): [HubAsset!]!
  hubSummaryHistory(request: HubSummaryHistoryRequest!): [HubSummarySample!]!
  reserve(request: ReserveRequest!): Reserve
  reserves(request: ReservesRequest!): [Reserve!]!
  supply(request: SupplyRequest!): ExecutionPlan!
  borrow(request: BorrowRequest!): ExecutionPlan!
  withdraw(request: WithdrawRequest!): ExecutionPlan!
  repay(request: RepayRequest!): ExecutionPlan!
  spokePositionManagers(request: SpokePositionManagersRequest!): PaginatedSpokePositionManagerResult!
  spokeUserPositionManagers(request: SpokeUserPositionManagersRequest!): PaginatedSpokeUserPositionManagerResult!
  setSpokeUserPositionManager(request: SetSpokeUserPositionManagerRequest!): TransactionRequest!
  renounceSpokeUserPositionManager(request: RenounceSpokeUserPositionManagerRequest!): TransactionRequest!
  setUserSuppliesAsCollateral(request: SetUserSuppliesAsCollateralRequest!): TransactionRequest!
  liquidatePosition(request: LiquidatePositionRequest!): LiquidatePositionExecutionPlan!
  updateUserPositionConditions(request: UpdateUserPositionConditionsRequest!): TransactionRequest!
  preview(request: PreviewRequest!): PreviewUserPosition!
  borrowApyHistory(request: BorrowApyHistoryRequest!): [ApySample!]!
  supplyApyHistory(request: SupplyApyHistoryRequest!): [ApySample!]!
  spoke(request: SpokeRequest!): Spoke

  """Lists all spokes"""
  spokes(request: SpokesRequest!): [Spoke!]!

  """
  Get the user balances.
  This will only return assets that can be used on the protocol.
  """
  userBalances(request: UserBalancesRequest!): [UserBalance!]!
  userBorrows(request: UserBorrowsRequest!): [UserBorrowItem!]!
  userSummary(request: UserSummaryRequest!): UserSummary!
  userSummaryHistory(request: UserSummaryHistoryRequest!): [UserSummaryHistoryItem!]!
  userPositions(request: UserPositionsRequest!): [UserPosition!]!
  userPosition(request: UserPositionRequest!): UserPosition
  userSupplies(request: UserSuppliesRequest!): [UserSupplyItem!]!
  userRiskPremiumBreakdown(request: UserRiskPremiumBreakdownRequest!): [UserRiskPremiumBreakdownItem!]!

  """
  This lets you know the API has processed the known transaction hash, as the API uses caching to make things as fast
  as possible, it has an invalidation task, so sometimes if the receipt is complete, we may still (rarely) serve
  old data for 100-200ms longer, it's best to query after you got the receipt to be told that it is ready to go.
  Note the invalidation is very quick, and most of the time it's present even before your receipt is returned this is to
  cater for the race condition.
  """
  hasProcessedKnownTransaction(request: HasProcessedKnownTransactionRequest!): Boolean!
  activities(request: ActivitiesRequest!): PaginatedActivitiesResult!
  tokenSwapQuote(request: TokenSwapQuoteRequest!): TokenSwapQuoteResult!
  prepareTokenSwap(request: PrepareTokenSwapRequest!): PrepareTokenSwapResult!
  supplySwapQuote(request: SupplySwapQuoteRequest!): SupplySwapQuoteResult!
  borrowSwapQuote(request: BorrowSwapQuoteRequest!): BorrowSwapQuoteResult!
  repayWithSupplyQuote(request: RepayWithSupplyQuoteRequest!): RepayWithSupplyQuoteResult!
  withdrawSwapQuote(request: WithdrawSwapQuoteRequest!): WithdrawSwapQuoteResult!
  preparePositionSwap(request: PreparePositionSwapRequest!): PreparePositionSwapResult!
  swapStatus(request: SwapStatusRequest!): SwapStatus!
  userSwaps(request: UserSwapsRequest!): PaginatedUserSwapsResult!
  prepareSwapCancel(request: PrepareSwapCancelRequest!): PrepareSwapCancelResult!
  swappableTokens(request: SwappableTokensRequest!): [Token!]!
}

"""Quote accuracy level for swap quotes"""
enum QuoteAccuracy {
  """Fast price quality - faster response, potentially less accurate price"""
  FAST

  """Verified price quality - more accurate price (default)"""
  ACCURATE
}

input RenounceSpokeUserPositionManagerRequest {
  """The spoke id"""
  spoke: SpokeId!

  """The address to remove as a position manager"""
  manager: EvmAddress!

  """The address to remove `manager` as position manager"""
  managing: EvmAddress!
}

type RepayActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  repaid: Erc20Amount!
  chain: Chain!
}

input RepayAmountInputWithPermit @oneOf {
  """The native amount"""
  native: AmountInput

  """The erc20 amount input"""
  erc20: RepayErc20AmountInputWithPermit
}

input RepayErc20AmountInputWithPermit {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: AmountInput!

  """
  The signed ERC20 permit message to operate on the relevant token without a need for an ERC20 Approval transaction.
  """
  permitSig: ERC20PermitSignature
}

input RepayPermitRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount repaying"""
  amount: AmountInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

input RepayRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount repaying"""
  amount: RepayAmountInputWithPermit!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

enum RepayWithSupplyKind {
  REPAY
  SUPPLY
}

input RepayWithSupplyQuoteRequest @oneOf {
  market: MarketRepayWithSupplyQuoteInput
  limit: LimitRepayWithSupplyQuoteInput
  fromQuote: FromQuoteRepayWithSupplyQuoteInput
}

union RepayWithSupplyQuoteResult = PositionSwapByIntentApprovalsRequired

type Reserve {
  id: ReserveId!
  onChainId: OnChainReserveId!
  borrowCap: BigDecimal!
  supplyCap: BigDecimal!
  chain: Chain!
  summary: ReserveSummary!
  settings: ReserveSettings!
  status: ReserveStatus!
  canBorrow: Boolean!
  canSupply: Boolean!
  canUseAsCollateral: Boolean!
  canSwapFrom: Boolean!
  userState: ReserveUserState
  asset: HubAsset!
  spoke: Spoke!
}

input ReserveAmountInput @oneOf {
  """The native amount"""
  native: BigDecimal

  """The erc20 amount input"""
  erc20: ReserveErc20AmountInput
}

input ReserveAmountInputWithPermit @oneOf {
  """The native amount"""
  native: BigDecimal

  """The erc20 amount input"""
  erc20: ReserveErc20AmountInputWithPermit
}

input ReserveErc20AmountInput {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: BigDecimal!
}

input ReserveErc20AmountInputWithPermit {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: BigDecimal!

  """
  The signed ERC20 permit message to operate on the relevant token without a need for an ERC20 Approval transaction.
  """
  permitSig: ERC20PermitSignature
}

scalar ReserveId

type ReserveInfo {
  id: ReserveId!
  asset: HubAsset!
}

input ReserveInput {
  chainId: ChainId!
  spoke: EvmAddress!
  onChainId: OnChainReserveId!
}

input ReserveRequest {
  query: ReserveRequestQuery!

  """
  The user who is doing the query (this injects user state into some of the return objects)
  """
  user: EvmAddress
}

input ReserveRequestQuery @oneOf {
  reserveId: ReserveId
  reserveInput: ReserveInput
}

type ReserveSettings {
  collateralFactor: PercentNumber!
  maxLiquidationBonus: PercentNumber!
  liquidationFee: PercentNumber!
  collateralRisk: PercentNumber!
  borrowable: Boolean!
  collateral: Boolean!
  suppliable: Boolean!
  latestDynamicConfigKey: DynamicConfigKey!
}

type ReserveStatus {
  frozen: Boolean!
  paused: Boolean!
  active: Boolean!
}

type ReserveSummary {
  supplied: Erc20Amount!
  borrowed: Erc20Amount!
  supplyApy: PercentNumber!
  borrowApy: PercentNumber!
}

type ReserveUserState {
  balance: Erc20Amount!
  suppliable: Erc20Amount!
  borrowable: Erc20Amount!
  borrowApy: PercentNumber!
  collateralFactor: PercentNumber!
  maxLiquidationBonus: PercentNumber!
  liquidationFee: PercentNumber!
  dynamicConfigKey: DynamicConfigKey!
}

input ReservesRequest {
  """The reserve's request query"""
  query: ReservesRequestQuery!

  """
  The user who is doing the query (this injects user state into some of the return objects)
  """
  user: EvmAddress

  """The reserve's filter"""
  filter: ReservesRequestFilter! = ALL

  """The reserve's order by"""
  orderBy: ReservesRequestOrderBy! = {assetName: ASC}
}

enum ReservesRequestFilter {
  SUPPLY
  BORROW
  COLLATERAL
  ALL
}

input ReservesRequestOrderBy @oneOf {
  assetName: OrderDirection
  userBalance: OrderDirection
  supplyApy: OrderDirection
  supplyAvailable: OrderDirection
  borrowApy: OrderDirection
  borrowAvailable: OrderDirection
  collateralFactor: OrderDirection
}

input ReservesRequestQuery @oneOf {
  """Get all the reserves for a spoke"""
  spoke: SpokeInput

  """Get all the reserves for a spoke"""
  spokeId: SpokeId

  """Get all the reserves with underlying tokens"""
  tokens: [Erc20Input!]

  """Get all the reserves on a hub for an underlying"""
  hubToken: HubTokenInput

  """Get all the reserves on a hub for an underlying by a hub id"""
  hubIdToken: HubIdTokenInput

  """Get all the reserves on a list of chains"""
  chainIds: [ChainId!]

  """Get all the reserves for a spoke for an underlying"""
  spokeToken: SpokeTokenInput

  """Get all reserves on a hub"""
  hub: HubInput

  """Get all reserves with a hub id"""
  hubId: HubId

  """Get all the reserves on based on user position id"""
  userPositionId: UserPositionId

  """Get all the reserves based on the token categories"""
  chainTokenCategories: [ChainTokenCategories!]
}

input SetSpokeUserPositionManagerRequest {
  """The spoke id"""
  spoke: SpokeId!

  """The address to become the position manager"""
  manager: EvmAddress!

  """Approve or remove the manager"""
  approve: Boolean!

  """The user to set the position `manager` for"""
  user: EvmAddress!

  """The signature"""
  signature: ERC20PermitSignature
}

input SetUserSuppliesAsCollateralRequest {
  """The collateral to make changes to"""
  changes: [UserSupplyAsCollateral!]!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

scalar Signature

type Spoke {
  """The id for the spoke"""
  id: SpokeId!

  """The spoke name (offchain)"""
  name: String!

  """The spoke address"""
  address: EvmAddress!

  """The spoke chain"""
  chain: Chain!
}

scalar SpokeId

input SpokeInput {
  """The address of the spoke"""
  address: EvmAddress!

  """The chain id the spoke is deployed to"""
  chainId: ChainId!
}

input SpokePositionManagersRequest {
  spoke: SpokeId!
  includeInactive: Boolean
  pageSize: PageSize!
  cursor: Cursor
}

type SpokePositionManger {
  name: String!
  address: EvmAddress!
  active: Boolean!
}

input SpokeRequest {
  """The spoke request query"""
  query: SpokeRequestQuery!
}

input SpokeRequestQuery @oneOf {
  spoke: SpokeInput
  spokeId: SpokeId
}

input SpokeTokenInput {
  """The spoke id"""
  spoke: SpokeId!

  """The token"""
  token: EvmAddress!
}

type SpokeUserPositionManager {
  name: String!
  address: EvmAddress!
  approvedOn: DateTime!
  active: Boolean!
}

input SpokeUserPositionManagersRequest {
  spoke: SpokeId!
  user: EvmAddress!
  pageSize: PageSize!
  cursor: Cursor
}

input SpokesRequest {
  query: SpokesRequestQuery!
}

input SpokesRequestQuery @oneOf {
  """
  The hub id
  Get all the spokes which hubs are linked to a spoke reserve
  """
  hubId: HubId

  """
  The hub address and chain id
  Get all the spokes which hubs are linked to a spoke reserve
  """
  hub: HubInput

  """
  The chain ids
  Get all the spokes which are on the list of chain ids
  """
  chainIds: [ChainId!]
}

type SupplyActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  supplied: Erc20Amount!
  chain: Chain!
}

input SupplyApyHistoryRequest {
  reserve: ReserveId!
  window: TimeWindow! = LAST_DAY
}

input SupplyPermitRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount supplying"""
  amount: ReserveErc20AmountInput!

  """If you wish to enable collateral with it meaning you can borrow"""
  enableCollateral: Boolean! = true

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

input SupplyRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount supplying"""
  amount: ReserveAmountInputWithPermit!

  """If you wish to enable collateral with it meaning you can borrow"""
  enableCollateral: AlwaysTrue

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

enum SupplySwapKind {
  CURRENT
  NEW
}

input SupplySwapQuoteRequest @oneOf {
  market: MarketSupplySwapQuoteInput
  limit: LimitSupplySwapQuoteInput
  fromQuote: FromQuoteSupplySwapQuoteInput
}

union SupplySwapQuoteResult = PositionSwapByIntentApprovalsRequired

union SwapAmount = PositionAmount | NativeAmount | Erc20Amount

type SwapByIntent {
  quote: SwapQuote!
}

input SwapByIntentInput {
  quoteId: SwapQuoteId!
  signature: Signature!
}

type SwapByIntentWithApprovalRequired {
  quote: SwapQuote!
  approval: Erc20Approval!
}

type SwapByTransaction {
  quote: SwapQuote!
}

type SwapCancelled {
  createdAt: DateTime!
  cancelledAt: DateTime
  explorerLink: String!
}

input SwapErc20Input {
  address: EvmAddress!
  value: BigDecimal!
}

union SwapExecutionPlan = SwapTransactionRequest | SwapReceipt | InsufficientBalanceError

type SwapExpired {
  createdAt: DateTime!
  expiredAt: DateTime!
  explorerLink: String!
}

type SwapFulfilled {
  txHash: String!
  desiredSell: SwapAmount!
  desiredBuy: SwapAmount!
  sold: SwapAmount!
  bought: SwapAmount!
  createdAt: DateTime!
  fulfilledAt: DateTime!
  explorerLink: String!
  refundTxHash: TxHash
}

scalar SwapId

enum SwapKind {
  BUY
  SELL
}

type SwapOpen {
  swapId: SwapId!
  createdAt: DateTime!
  deadline: DateTime!
  explorerLink: String!
  desiredSell: SwapAmount!
  desiredBuy: SwapAmount!
}

type SwapPendingSignature {
  createdAt: DateTime!
  deadline: DateTime!
  explorerLink: String!
}

type SwapQuote {
  accuracy: QuoteAccuracy!
  quoteId: SwapQuoteId!
  suggestedSlippage: PercentNumber!
  sell: TokenAmount!
  buy: TokenAmount!
  costs: SwapQuoteCosts!

  """Final buy amount after all fees and slippage"""
  finalBuy: TokenAmount!

  """Final sell amount after all fees and slippage"""
  finalSell: TokenAmount!
}

type SwapQuoteCosts {
  """Network and provider costs"""
  networkCosts: TokenAmount!

  """Aave partner fee amount"""
  partnerFee: TokenAmount!

  """Protocol fee"""
  flashloanFee: TokenAmount

  """Custom Swap Provider fee"""
  providerFee: TokenAmount!
}

scalar SwapQuoteId

type SwapReceipt {
  id: SwapId!
  createdAt: DateTime!
  explorerLink: String!
}

input SwapRequest @oneOf {
  intent: SwapByIntentInput
  transaction: SwapWithTransactionInput
}

union SwapStatus = SwapOpen | SwapPendingSignature | SwapCancelled | SwapExpired | SwapFulfilled

enum SwapStatusFilter {
  CANCELLED
  EXPIRED
  FULFILLED
  OPEN
  PENDING_SIGNATURE
}

input SwapStatusRequest {
  id: SwapId!
}

input SwapTokenInput @oneOf {
  native: BigDecimal
  erc20: SwapErc20Input
}

type SwapTransactionRequest {
  transaction: TransactionRequest!
  orderReceipt: SwapReceipt!
}

type SwapTypedData {
  types: JSON!
  primaryType: String!
  domain: DomainData!
  message: JSON!
}

input SwapWithTransactionInput {
  quoteId: SwapQuoteId!
  permitSig: Signature

  """
  Whether the swap order creator is a smart contract wallet. If not provided, it will be inferred following the ERC-1271 standard.
  """
  isSenderSmartContractWallet: Boolean
}

input SwappableTokenInput @oneOf {
  native: ChainId
  erc20: Erc20Input
}

input SwappableTokensRequest {
  query: SwappableTokensRequestQuery
}

input SwappableTokensRequestQuery @oneOf {
  chainIds: [ChainId!]
  from: SwappableTokenInput
  to: SwappableTokenInput
}

enum TimeWindow {
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  LAST_SIX_MONTHS
  LAST_YEAR
  ALL
}

union Token = NativeToken | Erc20Token

union TokenAmount = NativeAmount | Erc20Amount

enum TokenCategory {
  STABLECOIN
  ETH_CORRELATED
}

type TokenInfo {
  """The token info id"""
  id: TokenInfoId!

  """The token name"""
  name: String!

  """The token symbol"""
  symbol: String!

  """The token icon"""
  icon: String!

  """The token decimals"""
  decimals: Int!

  """The token category,"""
  categories: [TokenCategory!]!
}

scalar TokenInfoId

input TokenInput @oneOf {
  """Native token"""
  native: AlwaysTrue

  """The erc20 address"""
  erc20: EvmAddress
}

input TokenSwapQuoteRequest @oneOf {
  market: MarketOrderTokenSwapQuoteInput
  limit: LimitOrderTokenSwapQuoteInput
  fromQuote: MarketOrderTokenSwapFromQuoteInput
}

union TokenSwapQuoteResult = SwapByIntent | SwapByIntentWithApprovalRequired | SwapByTransaction

type TransactionRequest {
  to: EvmAddress!
  from: EvmAddress!
  data: BlockchainData!
  value: BigInt!
  chainId: ChainId!
  operations: [OperationType!]
}

scalar TxHash

input TxHashInput {
  txHash: TxHash!
  chainId: ChainId!
}

type TypeDefinition {
  EIP712Domain: [TypeField!]!
  Permit: [TypeField!]!
}

type TypeField {
  name: String!
  type: String!
}

input UpdateUserPositionConditionsRequest {
  userPositionId: UserPositionId!
  update: UserPositionConditionsUpdate!
}

type UpdatedDynamicConfigActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  collateralFactor: PercentNumberChangeSnapshot!
  maxLiquidationBonus: PercentNumberChangeSnapshot!
  liquidationFee: PercentNumberChangeSnapshot!
  chain: Chain!
}

type UpdatedRiskPremiumActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  premium: PercentNumberChangeSnapshot!
  chain: Chain!
}

type UserBalance {
  """The user balance id"""
  id: UserBalanceId!

  """The token info"""
  info: TokenInfo!

  """The balances across chains it will be 1 item per chain"""
  balances: [TokenAmount!]!

  """The total amount summed across all balances"""
  totalAmount: DecimalNumber!

  """The total exchange amount summed across all balances"""
  exchange(currency: Currency! = USD): ExchangeAmount!

  """The supply apy dependent on what you pass in for the `metric`"""
  supplyApy(metric: ApyMetric! = HIGHEST): PercentNumber!

  """The borrow APY dependent on what you pass in for the `metric`"""
  borrowApy(metric: ApyMetric! = HIGHEST): PercentNumber!

  """The collateral factor dependent on what you pass in for the `metric`"""
  collateralFactor(metric: CollateralMetric! = HIGHEST): PercentNumber
}

scalar UserBalanceId

input UserBalancesByChains {
  """List of chains"""
  chainIds: [ChainId!]!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesByHub {
  """The hub address"""
  address: EvmAddress!

  """The hub chain id"""
  chainId: ChainId!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesByHubId {
  """The hub id"""
  hubId: HubId!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesBySpoke {
  """The spoke address"""
  address: EvmAddress!

  """The chain id the spoke is deployed to"""
  chainId: ChainId!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesByTokens {
  """The chain token input"""
  chainTokens: [ChainTokenInput!]!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesByUserPosition {
  """The user position id"""
  userPositionId: UserPositionId!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesRequest {
  """The user to get the balance for"""
  user: EvmAddress!

  """The order by clause - defaults to the highest USD value"""
  orderBy: UserBalancesRequestOrderBy! = {balance: DESC}

  """The user balance filter"""
  filter: UserBalancesRequestFilter!

  """If you want to include 0 balances in the return list"""
  includeZeroBalances: Boolean! = false
}

input UserBalancesRequestFilter @oneOf {
  """The balances for the tokens on the specified chains"""
  chains: UserBalancesByChains

  """The balances for the tokens of hub assets on a given hub"""
  hub: UserBalancesByHub

  """The balances for the tokens of the hub assets on a given hub id"""
  hubId: UserBalancesByHubId

  """The balances for the tokens of reserves attached to a spoke"""
  spoke: UserBalancesBySpoke

  """The balances for the swappable tokens"""
  swappable: SwappableTokensRequestQuery

  """
  The balances for the tokens of the spoke associated with the given user position
  """
  userPosition: UserBalancesByUserPosition

  """The balances for the chains tokens"""
  tokens: UserBalancesByTokens
}

input UserBalancesRequestOrderBy @oneOf {
  """The name of the token"""
  name: OrderDirection

  """The balance of the token"""
  balance: OrderDirection
}

type UserBorrowItem {
  """The user borrow item id"""
  id: UserBorrowItemId!

  """The reserve borrowed from"""
  reserve: Reserve!

  """The amount borrowed on this reserve"""
  principal: Erc20Amount!

  """The overall debt including accrued interests"""
  debt: Erc20Amount!

  """The interest incurred on the loan"""
  interest: Erc20Amount!

  """
  When the borrow was created.
  This is null if they have no supply item, for
  example, when using include_zero_balances this comes
  back as principal and debt as 0
  """
  createdAt: DateTime
}

scalar UserBorrowItemId

input UserBorrowsRequest {
  query: UserBorrowsRequestQuery!
  orderBy: UserBorrowsRequestOrderBy! = {amount: DESC}

  """If you wish to include zero balances in the results"""
  includeZeroBalances: Boolean! = false
}

input UserBorrowsRequestOrderBy @oneOf {
  assetName: OrderDirection
  created: OrderDirection
  amount: OrderDirection
  apy: OrderDirection
}

input UserBorrowsRequestQuery @oneOf {
  userSpoke: UserSpokeInput
  userToken: UserToken
  userPositionId: UserPositionId
  userChains: UserChains
  userHub: UserHub
}

input UserChains {
  user: EvmAddress!
  chainIds: [ChainId!]!
}

input UserHub {
  """The user address"""
  user: EvmAddress!

  """The user hub input"""
  hub: UserHubInput!
}

input UserHubInput @oneOf {
  input: HubInput
  id: HubId
}

type UserPosition {
  """The user position ID"""
  id: UserPositionId!

  """The user holding this position"""
  user: EvmAddress!
  createdAt: DateTime!
  totalSupplied(currency: Currency! = USD): ExchangeAmountWithChange!

  """
  Total collateral which is the full some of the assets supplied which are enabled as collateral
  """
  totalCollateral(currency: Currency! = USD): ExchangeAmountWithChange!

  """Total debt which is the total amount borrowed plus the accrued premium"""
  totalDebt(currency: Currency! = USD): ExchangeAmountWithChange!

  """The net balance which is `totalSupplied` - `totalDebt`"""
  netBalance(currency: Currency! = USD): ExchangeAmountWithChange!

  """The net collateral which is `totalCollateral` - `totalDebt`"""
  netCollateral(currency: Currency! = USD): ExchangeAmountWithChange!
  netApy: PercentNumber!
  netSupplyApy: PercentNumberWithChange!
  netBorrowApy: PercentNumberWithChange!

  """
  Net accrued interest earned (all supply interests - all borrow interests)
  """
  netAccruedInterest(currency: Currency! = USD): ExchangeAmount!
  healthFactor: HealthFactorWithChange!
  riskPremium: UserPositionRiskPremium

  """
  ExchangeAmount liquidation price if you only have one collateral more then
  1 collateral you should render health factor
  """
  liquidationPrice(currency: Currency! = USD): ExchangeAmount
  borrowingPower(currency: Currency! = USD): ExchangeAmount!
  canUpdateDynamicConfig: Boolean!
  netBalancePercentChange(window: TimeWindow! = LAST_DAY): PercentNumber!
  spoke: Spoke!
  averageCollateralFactor: PercentNumber!
}

union UserPositionConditionVariation = CollateralFactorVariation | LiquidationFeeVariation | MaxLiquidationBonusVariation

enum UserPositionConditionsUpdate {
  ALL_DYNAMIC_CONFIG
  JUST_RISK_PREMIUM
}

scalar UserPositionId

input UserPositionRequest @oneOf {
  userSpoke: UserSpokeInput
  id: UserPositionId
}

type UserPositionRiskPremium {
  current: PercentNumber!
  latest: PercentNumber!
  breakdown: [UserRiskPremiumBreakdownItem!]!
}

input UserPositionsRequest {
  """The user to get the positions for"""
  user: EvmAddress!

  """The filter for the user position"""
  filter: UserPositionsRequestFilter!

  """The ordering for the positions"""
  orderBy: UserPositionsRequestOrderBy! = {created: ASC}
}

input UserPositionsRequestFilter @oneOf {
  tokens: [Erc20Input!]
  chainIds: [ChainId!]
}

input UserPositionsRequestOrderBy @oneOf {
  created: OrderDirection
  balance: OrderDirection
  netApy: OrderDirection
  healthFactor: OrderDirection
  netCollateral: OrderDirection
}

type UserRiskPremiumBreakdownItem {
  token: Erc20Token!
  currentRiskPremiumWeight: PercentNumber!
  latestRiskPremiumWeight: PercentNumber!
  collateral: PercentNumber!
}

input UserRiskPremiumBreakdownRequest {
  query: UserRiskPremiumBreakdownRequestQuery!
  user: EvmAddress!
}

input UserRiskPremiumBreakdownRequestQuery @oneOf {
  userSpoke: UserSpokeInput
  userPositionId: UserPositionId
}

input UserSpokeInput {
  spoke: SpokeId!
  user: EvmAddress!
}

type UserSummary {
  totalPositions: Int!

  """Net balance = supply - debt"""
  netBalance(currency: Currency! = USD): ExchangeAmountWithChange!

  """Total supply where is_collateral is true"""
  totalCollateral(currency: Currency! = USD): ExchangeAmount!

  """Total supplied across all positions"""
  totalSupplied(currency: Currency! = USD): ExchangeAmount!

  """Total debt across all positions"""
  totalDebt(currency: Currency! = USD): ExchangeAmount!

  """
  Net APY = ( (supplied_amount_i * supply_apy_i) -  (borrowed_amount_j * borrow_apy_j)) / ( supplied_amount_i)
  """
  netApy: PercentNumber!

  """
  Net accrued interest earned (all supply interests - all borrow interests)
  """
  netAccruedInterest(currency: Currency! = USD): ExchangeAmount!

  """Lowest health factor across all positions"""
  lowestHealthFactor: BigDecimal
}

input UserSummaryFilter @oneOf {
  spoke: SpokeInput
  spokeId: SpokeId
  chainIds: [ChainId!]
  userPositionId: UserPositionId
}

type UserSummaryHistoryItem {
  healthFactor: BigDecimal
  date: DateTime!

  """The aggregated net balance for the time period"""
  netBalance(currency: Currency! = USD): ExchangeAmount!

  """The aggregated borrows for the time period"""
  borrows(currency: Currency! = USD): ExchangeAmount!

  """The aggregated supplies for the time period"""
  supplies(currency: Currency! = USD): ExchangeAmount!
}

input UserSummaryHistoryRequest {
  user: EvmAddress!
  filter: UserSummaryFilter
  window: TimeWindow! = LAST_DAY
}

input UserSummaryRequest {
  user: EvmAddress!
  filter: UserSummaryFilter
}

input UserSuppliesRequest {
  query: UserSuppliesRequestQuery!
  orderBy: UserSuppliesRequestOrderBy! = {amount: DESC}

  """If you wish to include zero balances in the results"""
  includeZeroBalances: Boolean! = false
}

input UserSuppliesRequestOrderBy @oneOf {
  assetName: OrderDirection
  created: OrderDirection
  amount: OrderDirection
  apy: OrderDirection
}

input UserSuppliesRequestQuery @oneOf {
  userSpoke: UserSpokeInput
  userToken: UserToken
  userPositionId: UserPositionId
  userChains: UserChains
  userHub: UserHub
}

input UserSupplyAsCollateral {
  """The reserve id"""
  reserve: ReserveId!

  """If you want to enable the collateral or disable"""
  enableCollateral: Boolean!
}

type UserSupplyItem {
  """The user supply item id"""
  id: UserSupplyItemId!

  """The reserve supplied to"""
  reserve: Reserve!

  """The amount supplied to this reserve"""
  principal: Erc20Amount!

  """The overall amount you can withdraw, including accrued interests"""
  withdrawable: Erc20Amount!

  """The interest amount earned on supplying"""
  interest: Erc20Amount!

  """If this supply is used as collateral"""
  isCollateral: Boolean!

  """
  When the supply was created.
  This is null if they have no supply item, for
  example, when using include_zero_balances this comes
  back as principal and withdrawable as 0
  """
  createdAt: DateTime
}

scalar UserSupplyItemId

input UserSwapsRequest {
  chainId: ChainId!
  user: EvmAddress!
  filterBy: [SwapStatusFilter!]
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

input UserToken {
  user: EvmAddress!
  token: Erc20Input!
}

type UsingAsCollateralActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  enabledAsCollateral: Boolean!
  chain: Chain!
}

type WithdrawActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  withdrawn: Erc20Amount!
  chain: Chain!
}

input WithdrawRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount withdrawing"""
  amount: WithdrawReserveAmountInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

input WithdrawReserveAmountInput @oneOf {
  """The native amount"""
  native: AmountInput

  """The erc20 amount input"""
  erc20: AmountInput
}

enum WithdrawSwapKind {
  WITHDRAW
  BUY
}

input WithdrawSwapQuoteRequest @oneOf {
  market: MarketWithdrawSwapQuoteInput
  limit: LimitWithdrawSwapQuoteInput
  fromQuote: FromQuoteWithdrawSwapQuoteInput
}

union WithdrawSwapQuoteResult = PositionSwapByIntentApprovalsRequired