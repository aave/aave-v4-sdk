type APYSample {
  date: DateTime!
  avgRate: PercentValue!
}

enum ActivityType {
  BORROW
  SUPPLY
  WITHDRAW
  REPAY
  LIQUIDATED
  SWAP
}

scalar AlwaysTrue

type ApprovalRequired {
  """The transaction requires an approval first"""
  approval: TransactionRequest!
  reason: String!

  """The required amount missing to be able to do the original transaction"""
  requiredAmount: DecimalValue!

  """The current allowance approved"""
  currentAllowance: DecimalValue!

  """The transaction to send after the approval is complete"""
  originalTransaction: TransactionRequest!
}

enum ApyMetric {
  HIGHEST
  LOWEST
}

scalar AssetId

enum BestBorrowReserveFilter {
  LOWEST_RATE
  LOWEST_AVERAGE_RATE
}

input BestBorrowReserveRequest {
  query: BestRatesRequestQuery!
  filter: BestBorrowReserveFilter!
}

input BestRatesRequestQuery @oneOf {
  spokes: [SpokeInput!]
  chainIds: [ChainId!]
}

enum BestSupplyReserveFilter {
  HIGHEST_YIELD
  HIGHEST_AVERAGE_YIELD
}

input BestSupplyReserveRequest {
  query: BestRatesRequestQuery!
  filter: BestSupplyReserveFilter!
}

scalar BigDecimal

type BigDecimalVariation {
  current: PercentValue!
  after: PercentValue!
}

type BigDecimalWithChange {
  value: BigDecimal!
}

scalar BigInt

scalar BlockchainData

input BorrowAPYHistoryRequest {
  spoke: SpokeInput!
  reserve: ReserveId!
  window: TimeWindow!
}

type BorrowActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  amount: Erc20Amount!
}

input BorrowRequest {
  reserve: ReserveInput!
  amount: ReserveAmountInput!
  sender: EvmAddress!
  onBehalfOf: EvmAddress!
}

input CancelIntentSwapInput {
  id: SwapId!
  signature: ERC712Signature!
}

union CancelSwapExecutionPlan = TransactionRequest | SwapCancelled

input CancelSwapRequest @oneOf {
  intent: CancelIntentSwapInput
  transaction: SwapId
}

type CancelSwapTypeDefinition {
  eip712Domain: [TypeField!]!
}

type CancelSwapTypedData {
  types: CancelSwapTypeDefinition!
  primaryType: String!
  domain: DomainData!
}

type Chain {
  name: String!
  icon: String!
  chainId: ChainId!
  explorerUrl: String!
  isTestnet: Boolean!
  nativeWrappedToken: EvmAddress!
  nativeInfo: TokenInfo!
}

"""A supported blockchain chain ID"""
scalar ChainId

input ChainTokenInput @oneOf {
  native: ChainId
  erc20: Erc20Input
}

enum ChainsFilter {
  TESTNET_ONLY
  MAINNET_ONLY
  ALL
}

enum Currency {
  USD
}

scalar Cursor

scalar DateTime

type DecimalValue {
  raw: BigInt!
  decimals: Int!
  formatted: BigDecimal!
}

type DomainData {
  name: String!
  version: String!
  chainId: ChainId!
  verifyingContract: EvmAddress!
}

input ERC712Signature {
  """The signature for the erc721"""
  value: Signature!

  """The deadline for the erc721"""
  deadline: Int!
}

type Erc20Amount {
  token: Erc20Token!
  value: DecimalValue!
  fiatAmount(currency: Currency! = USD): FiatAmount!
  fiatRate(currency: Currency! = USD): DecimalValue!
  isWrappedNative: Boolean!
}

input Erc20Input {
  address: EvmAddress!
  chainId: ChainId!
}

type Erc20Token {
  info: TokenInfo!
  contract: EvmAddress!
  chain: Chain!
}

scalar EvmAddress

union ExecutionPlan = TransactionRequest | ApprovalRequired | InsufficientBalanceError

type FiatAmount {
  value: DecimalValue!
  name: String!
  symbol: String!
}

type FiatAmountValueVariation {
  current: FiatAmount!
  after: FiatAmount!
}

type FiatAmountWithChange {
  value: FiatAmount!
}

input ForkTopUpErc20 {
  """The token address"""
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction
  """
  value: BigDecimal!
}

input ForkTopUpRequest {
  """The address you want the funds to be topped up against"""
  user: EvmAddress!

  """The erc20 information"""
  erc20: ForkTopUpErc20

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction
  """
  native: BigDecimal
}

type ForkTopUpResponse {
  message: String!

  """The tx hash of the newly created transaction"""
  txHash: String
}

input HasProcessedKnownTransactionRequest {
  """
  The operation type this is given to you on the TransactionRequest::operation
  """
  operations: [OperationType!]!

  """The tx hash"""
  txHash: TxHash!
}

type Hub {
  name: String!
  address: EvmAddress!
  chain: Chain!
  totalSupplied: FiatAmount!
  totalSupplyCap: FiatAmount!
  supplyUtilizationRate: PercentValue!
  totalBorrowed: FiatAmount!
  totalBorrowCap: FiatAmount!
  borrowUtilizationRate: PercentValue!
}

type HubAsset {
  assetId: AssetId!
  hub: Hub!
  underlying: Erc20Token!
  summary: HubAssetSummary!
  settings: HubAssetSettings!
  bestSupplyReserve: Reserve
  bestBorrowReserve: Reserve
  userState: HubAssetUserState
}

type HubAssetSettings {
  feeReceiver: EvmAddress!
  liquidityFee: PercentValue!
  irStrategy: EvmAddress!
  reinvestmentStrategy: EvmAddress!
}

enum HubAssetStatusType {
  ACTIVE
  FROZEN
  PAUSED
}

type HubAssetSummary {
  supplied: BigDecimal!
  borrowed: BigDecimal!
  availableLiquidity: BigDecimal!
  supplyApy: PercentValue!
  borrowApy: PercentValue!
  netApy: PercentValue!
  utilizationRate: PercentValue!
}

type HubAssetUserState {
  balance: TokenAmount!
}

input HubAssetsRequest {
  hub: EvmAddress
  user: EvmAddress
  include: [HubAssetStatusType!]! = [ACTIVE, FROZEN, PAUSED]
  orderBy: HubAssetsRequestOrderBy! = NAME
  chainId: ChainId!
}

enum HubAssetsRequestOrderBy {
  BALANCE
  NAME
}

input HubInput {
  address: EvmAddress!
  chainId: ChainId!
}

input HubRequest {
  hub: EvmAddress!
  chainId: ChainId!
}

input HubTokenInput {
  chainId: ChainId!
  hub: EvmAddress!
  token: TokenInput!
}

input HubsRequest @oneOf {
  tokens: [ChainTokenInput!]
  chainIds: [ChainId!]
}

type InsufficientBalanceError {
  """The amount required to do the original transaction"""
  required: DecimalValue!

  """The amount available in the wallet"""
  available: DecimalValue!
}

input LiquidatePositionDebtAmount @oneOf {
  exact: BigDecimal
  max: AlwaysTrue
}

input LiquidatePositionRequest {
  spoke: SpokeInput!
  collateral: ReserveId!
  debt: ReserveId!
  amount: LiquidatePositionDebtAmount!
  liquidator: EvmAddress!
  user: EvmAddress!
}

type LiquidatedActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  collateralReserve: ReserveInfo!
  debtReserve: ReserveInfo!
  collateralAmount: Erc20Amount!
  debtAmount: Erc20Amount!
  liquidator: EvmAddress!
}

type NativeAmount {
  token: NativeToken!
  value: DecimalValue!
  fiatAmount(currency: Currency! = USD): FiatAmount!
  fiatRate(currency: Currency! = USD): DecimalValue!
}

type NativeToken {
  info: TokenInfo!
  chain: Chain!
}

enum OperationType {
  BORROW
  REPAY
  RESERVE_USED_AS_COLLATERAL_ENABLED
  RESERVE_USED_AS_COLLATERAL_DISABLED
  SUPPLY
  USER_EMODE_SET
  WITHDRAW
  VAULT_DEPLOYED
  VAULT_DEPOSIT
  VAULT_FEE_UPDATED
  VAULT_FEE_WITHDRAWN
  VAULT_WITHDRAW
  LIQUIDATION
}

enum OrderDirection {
  ASC
  DESC
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedResultInfo {
  """The cursor to the previous page of results, if any."""
  prev: Cursor

  """The cursor to the next page of results, if any."""
  next: Cursor
}

type PaginatedSpokePositionManagerResult {
  items: [SpokePositionManger!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedSpokeUserPositionManagerResult {
  items: [SpokeUserPositionManger!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUserHistoryResult {
  items: [UserHistoryItem!]!
  pageInfo: PaginatedResultInfo!
}

input PendingSwapsRequest {
  user: EvmAddress!
}

type PercentValue {
  """The raw none normalized percentage (the value that lives onchain)"""
  raw: BigInt!

  """The decimals representing the precision of the onchain raw value"""
  decimals: Int!

  """The normalized percentage (1.0 = 100%)"""
  value: BigDecimal!

  """
  The human-readable formatted value you can render on a UI straight away.
  For example, this will turn `0.01232343` to `1.23`, it will always round to `2` decimal points.
  """
  formatted: BigDecimal!
}

type PercentValueVariation {
  current: PercentValue!
  after: PercentValue!
}

type PercentValueWithChange {
  value: PercentValue!
}

type PermitMessageData {
  owner: EvmAddress!
  spender: EvmAddress!
  value: BigInt!
  nonce: BigInt!
  deadline: Int!
}

input PermitRequest {
  """The spender (when doing this with aave this is the market address)"""
  spender: EvmAddress!

  """The token you want to do the permit with"""
  currency: EvmAddress!

  """
  The amount to permit - in human-readable form aka 0.001 eth is 0.001 eth here
  """
  amount: BigDecimal!

  """The chain id the pool is deployed on"""
  chainId: ChainId!

  """The owner of the funds"""
  owner: EvmAddress!
}

type PermitTypedDataResponse {
  types: TypeDefinition!
  primaryType: String!
  domain: DomainData!
  message: PermitMessageData!
}

input PrepareLimitOrderSwapInput {
  chainId: ChainId!
  buy: TokenInput!
  sell: TokenInput!
  sellAmount: BigDecimal!
  buyAmount: BigDecimal!
  user: EvmAddress!
  slippage: SlippageInput!
}

input PrepareMarketOrderSwapInput {
  chainId: ChainId!
  buy: TokenInput!
  sell: TokenInput!
  amount: BigDecimal!
  kind: SwapKind!
  user: EvmAddress!
}

input PrepareSwapCancelRequest {
  id: SwapId!
}

type PrepareSwapCancelResult {
  data: CancelSwapTypedData!
}

input PrepareSwapRequest @oneOf {
  market: PrepareMarketOrderSwapInput
  limit: PrepareLimitOrderSwapInput
}

union PrepareSwapResult = SwapByIntent | SwapByIntentWithApprovalRequired | SwapByTransaction

input PreviewAction @oneOf {
  supply: SupplyRequest
  borrow: BorrowRequest
  repay: RepayRequest
  withdraw: WithdrawRequest
}

input PreviewRequest {
  action: PreviewAction!
}

type PreviewUserPositionResult {
  healthFactor: BigDecimalVariation
  positionAPY: PercentValueVariation!
  netAPY: PercentValueVariation!
  riskPremium: PercentValueVariation
  netCollateral: FiatAmountValueVariation!
  netDebt: FiatAmountValueVariation!
}

type Query {
  health: Boolean!
  chains(filter: ChainsFilter!): [Chain!]!

  """Generate EIP-712 typed data for EIP-2612 permit signature"""
  permitTypedData(request: PermitRequest!): PermitTypedDataResponse!

  """Lists all the hubs"""
  hubs(request: HubsRequest!): [Hub!]!
  hub(request: HubRequest!): Hub
  hubAssets(request: HubAssetsRequest!): [HubAsset!]!
  reserves(request: ReservesRequest!): [Reserve!]!
  supply(request: SupplyRequest!): ExecutionPlan!
  borrow(request: BorrowRequest!): ExecutionPlan!
  withdraw(request: WithdrawRequest!): ExecutionPlan!
  repay(request: RepayRequest!): ExecutionPlan!
  spokePositionManagers(request: SpokePositionManagersRequest!): PaginatedSpokePositionManagerResult!
  spokeUserPositionManagers(request: SpokeUserPositionManagersRequest!): PaginatedSpokeUserPositionManagerResult!
  setSpokeUserPositionManager(request: SetSpokeUserPositionManagerRequest!): TransactionRequest!
  renounceSpokeUserPositionManager(request: RenounceSpokeUserPositionManagerRequest!): TransactionRequest!
  setUserSupplyAsCollateral(request: SetUserSupplyAsCollateralRequest!): TransactionRequest!
  liquidatePosition(request: LiquidatePositionRequest!): ExecutionPlan!
  updateUserRiskPremium(request: UpdateUserRiskPremiumRequest!): TransactionRequest!
  updateUserDynamicConfig(request: UpdateUserDynamicConfigRequest!): TransactionRequest!
  preview(request: PreviewRequest!): PreviewUserPositionResult!
  bestSupplyReserve(request: BestSupplyReserveRequest!): Reserve!
  bestBorrowReserve(request: BestBorrowReserveRequest!): Reserve!
  borrowApyHistory(request: BorrowAPYHistoryRequest!): [APYSample!]!
  supplyApyHistory(request: SupplyAPYHistoryRequest!): [APYSample!]!

  """Lists all spokes"""
  spokes(request: SpokesRequest!): [Spoke!]!
  userBalances(request: UserBalancesRequest!): [UserBalance!]!
  userBorrows(request: UserBorrowsRequest!): [UserBorrowItem!]!
  userHistory(request: UserHistoryRequest!): PaginatedUserHistoryResult!
  userSummary(request: UserSummaryRequest!): UserSummary!
  userSummaryHistory(request: UserSummaryHistoryRequest!): [UserSummaryHistoryItem!]!
  userPositions(request: UserPositionsRequest!): [UserPosition!]!
  userPosition(request: UserPositionRequest!): UserPosition!
  userSupplies(request: UserSuppliesRequest!): [UserSupplyItem!]!

  """
  This lets you know the API has processed the known transaction hash, as the API uses caching to make things as fast
  as possible, it has an invalidation task, so sometimes if the receipt is complete, we may still (rarely) serve
  old data for 100-200ms longer, it's best to query after you got the receipt to be told that it is ready to go.
  Note the invalidation is very quick, and most of the time it's present even before your receipt is returned this is to
  cater for the race condition.
  """
  hasProcessedKnownTransaction(request: HasProcessedKnownTransactionRequest!): Boolean!
  swapQuote(request: SwapQuoteRequest!): SwapQuote!
  prepareSwap(request: PrepareSwapRequest!): PrepareSwapResult!
  swap(request: SwapRequest!): SwapExecutionPlan!
  swapStatus(request: SwapStatusRequest!): SwapStatus!
  pendingSwaps(request: PendingSwapsRequest!): [SwapReceipt!]!
  prepareSwapCancel(request: PrepareSwapCancelRequest!): PrepareSwapCancelResult!
  cancelSwap(request: CancelSwapRequest!): CancelSwapExecutionPlan!
  swappableTokens(request: SwappableTokensRequest!): [Token!]!

  """Top up a balance for a user or yourself on the fork"""
  forkTopUp(request: ForkTopUpRequest!): ForkTopUpResponse!
  _service: _Service!
}

input RenounceSpokeUserPositionManagerRequest {
  spoke: SpokeInput!
  managing: EvmAddress!
  manager: EvmAddress!
}

type RepayActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  amount: Erc20Amount!
}

input RepayRequest {
  reserve: ReserveInput!
  amount: ReserveAmountInputWithPermit!
  sender: EvmAddress!
  onBehalfOf: EvmAddress!
}

type Reserve {
  id: ReserveId!
  spoke: Spoke!
  assetId: AssetId!
  borrowCap: BigDecimal!
  supplyCap: BigDecimal!
  chain: Chain!
  summary: ReserveSummary!
  settings: ReserveSettings!
  status: ReserveStatus!
  canBorrow: Boolean!
  canUseAsCollateral: Boolean!
  userState: ReserveUserState
  asset: HubAsset!
}

input ReserveAmountInput @oneOf {
  native: BigDecimal
  erc20: ReserveErc20AmountInput
}

input ReserveAmountInputWithPermit @oneOf {
  """The native amount"""
  native: BigDecimal

  """The erc20 amount input"""
  erc20: ReserveErc20AmountInputWithPermit
}

input ReserveErc20AmountInput {
  value: BigDecimal!
}

input ReserveErc20AmountInputWithPermit {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: BigDecimal!

  """
  The signed ERC20 permit message to operate on the relevant token without a need for an ERC20 Approval transaction.
  """
  permitSig: ERC712Signature
}

scalar ReserveId

type ReserveInfo {
  id: ReserveId!
  spoke: Spoke!
  asset: HubAsset!
  chain: Chain!
}

input ReserveInput {
  """The chain id"""
  chainId: ChainId!

  """The spoke address"""
  spoke: EvmAddress!

  """The reserve id"""
  reserveId: ReserveId!
}

type ReserveSettings {
  collateralFactor: PercentValue!
  liquidationBonus: PercentValue!
  collateralRisk: PercentValue!
  borrowable: Boolean!
  collateral: Boolean!
}

type ReserveStatus {
  frozen: Boolean!
  paused: Boolean!
}

type ReserveSummary {
  supplied: Erc20Amount!
  borrowed: Erc20Amount!
  supplyApy: PercentValue!
  borrowApy: PercentValue!
}

type ReserveUserState {
  balance: Erc20Amount!
  suppliable: Erc20Amount!
  borrowable: Erc20Amount!
  borrowApy: PercentValue!
}

enum ReservesFilterRequest {
  SUPPLY
  BORROW
  ALL
}

input ReservesRequest {
  query: ReservesRequestQuery!
  user: EvmAddress
  filter: ReservesFilterRequest!
  orderBy: ReservesRequestOrderBy! = {name: ASC}
}

input ReservesRequestOrderBy @oneOf {
  name: OrderDirection
  balance: OrderDirection
  apy: OrderDirection
  collateralFactor: OrderDirection
}

input ReservesRequestQuery @oneOf {
  spoke: SpokeInput
  token: ChainTokenInput
  hubToken: HubTokenInput
}

input SetSpokeUserPositionManagerRequest {
  spoke: SpokeInput!
  manager: EvmAddress!
  approve: Boolean!
}

input SetUserSupplyAsCollateralRequest {
  reserve: ReserveInput!
  user: EvmAddress!
  enableCollateral: Boolean!
  signature: ERC712Signature
}

scalar Signature

input SlippageInput @oneOf {
  custom: BigDecimal
  suggested: BigDecimal
}

type Spoke {
  name: String!
  address: EvmAddress!
  chain: Chain!
  config: SpokeConfig!
}

type SpokeConfig {
  canSetPositionManager: Boolean!
  active: Boolean!
}

input SpokeInput {
  address: EvmAddress!
  chainId: ChainId!
}

input SpokePositionManagersRequest {
  spoke: SpokeInput!
  pageSize: PageSize!
  cursor: Cursor
}

type SpokePositionManger {
  name: String
  address: EvmAddress!
}

input SpokeUserPositionManagersRequest {
  spoke: SpokeInput!
  pageSize: PageSize!
  cursor: Cursor
}

type SpokeUserPositionManger {
  name: String
  address: EvmAddress!
  enabledAt: DateTime!
}

input SpokesRequest {
  hub: HubInput!
  chainIds: [ChainId!]!
}

input SupplyAPYHistoryRequest {
  spoke: SpokeInput!
  reserve: ReserveId!
  window: TimeWindow!
}

type SupplyActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  amount: Erc20Amount!
}

input SupplyRequest {
  """The reserve"""
  reserve: ReserveInput!

  """The amount supplying"""
  amount: ReserveAmountInputWithPermit!

  """If you wish to enable collateral with it meaning you can borrow"""
  enableCollateral: Boolean! = true

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """
  If not supplied, this will use `sender` which is the normal route - you can only use on
  `onBehalfOf` if you're a position manager for that user
  """
  onBehalfOf: EvmAddress
}

type SwapActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  sellAmount: TokenAmount!
  buyAmount: TokenAmount!
  executedSellAmount: TokenAmount!
  executedBuyAmount: TokenAmount!
  createdAt: DateTime!
  fulfilledAt: DateTime!
  explorerLink: String!
}

type SwapApprovalRequired {
  approval: TransactionRequest!
  originalTransaction: SwapTransactionRequest!
}

type SwapByIntent {
  id: SwapRequestId!
  quote: SwapQuote!
  data: SwapByIntentTypedData!
}

input SwapByIntentInput {
  id: SwapRequestId!
  signature: ERC712Signature!
}

type SwapByIntentTypeDefinition {
  eip712Domain: [TypeField!]!
}

type SwapByIntentTypedData {
  types: SwapByIntentTypeDefinition!
  primaryType: String!
  domain: DomainData!
}

type SwapByIntentWithApprovalRequired {
  id: SwapRequestId!
  approval: TransactionRequest!
  quote: SwapQuote!
  data: SwapByIntentTypedData!
}

type SwapByTransaction {
  id: SwapRequestId!
  quote: SwapQuote!
}

type SwapCancelled {
  createdAt: DateTime!
  cancelledAt: DateTime!
  explorerLink: String!
}

union SwapExecutionPlan = SwapTransactionRequest | SwapApprovalRequired | InsufficientBalanceError | SwapReceipt

type SwapExpired {
  createdAt: DateTime!
  expiredAt: DateTime!
  explorerLink: String!
}

type SwapFulfilled {
  txHash: String!
  sellAmount: TokenAmount!
  buyAmount: TokenAmount!
  executedSellAmount: TokenAmount!
  executedBuyAmount: TokenAmount!
  createdAt: DateTime!
  fulfilledAt: DateTime!
  explorerLink: String!
}

scalar SwapId

enum SwapKind {
  BUY
  SELL
}

type SwapOpen {
  swapId: SwapId!
  createAt: DateTime!
  deadline: DateTime!
  explorerLink: String!
  sellAmount: TokenAmount!
  buyAmount: TokenAmount!
}

type SwapPendingSignature {
  createdAt: DateTime!
  deadline: DateTime!
  explorerLink: String!
  signer: EvmAddress!
}

type SwapQuote {
  suggestedSlippage: PercentValue!
  sellAmount: TokenAmount!
  buyAmount: TokenAmount!
  costs: SwapQuoteCosts!
  minimumReceived: TokenAmount!
}

type SwapQuoteCosts {
  networkCosts: TokenAmount!
  partnerFeeAmount: TokenAmount!
}

input SwapQuoteRequest {
  chainId: ChainId!
  buy: TokenInput!
  sell: TokenInput!
  amount: BigDecimal!
  kind: SwapKind!
}

type SwapReceipt {
  id: SwapId!
  explorerLink: String!
}

input SwapRequest @oneOf {
  intent: SwapByIntentInput
  transaction: SwapWithTransactionInput
}

scalar SwapRequestId

union SwapStatus = SwapOpen | SwapPendingSignature | SwapCancelled | SwapExpired | SwapFulfilled

input SwapStatusRequest {
  id: SwapId!
}

type SwapTransactionRequest {
  transaction: TransactionRequest!
  orderReceipt: SwapReceipt!
}

input SwapWithTransactionInput {
  id: SwapRequestId!
  permitSig: ERC712Signature
}

input SwappableTokensRequest {
  query: SwappableTokensRequestQuery
}

input SwappableTokensRequestQuery {
  chainId: ChainId!
}

enum TimeWindow {
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  LAST_SIX_MONTHS
  LAST_YEAR
  ALL
}

union Token = NativeToken | Erc20Token

union TokenAmount = NativeAmount | Erc20Amount

type TokenInfo {
  name: String!
  symbol: String!
  icon: String!
  decimals: Int!
}

input TokenInput @oneOf {
  native: AlwaysTrue
  erc20: EvmAddress
}

type TransactionRequest {
  to: EvmAddress!
  from: EvmAddress!
  data: BlockchainData!
  value: BigInt!
  chainId: ChainId!
  operations: [OperationType!]!
}

scalar TxHash

type TypeDefinition {
  EIP712Domain: [TypeField!]!
  Permit: [TypeField!]!
}

type TypeField {
  name: String!
  type: String!
}

input UpdateUserDynamicConfigRequest {
  spoke: SpokeInput!
  user: EvmAddress!
}

input UpdateUserRiskPremiumRequest {
  spoke: SpokeInput!
  user: EvmAddress!
}

type UserBalance {
  info: TokenInfo!
  totalAmount: DecimalValue!
  balances: [TokenAmount!]!
  fiatAmount(currency: Currency! = USD): FiatAmount!
  supplyApy(metric: ApyMetric! = HIGHEST): PercentValue!
  borrowApy(metric: ApyMetric! = HIGHEST): PercentValue!
}

input UserBalancesRequest {
  user: EvmAddress!
  orderBy: UserBalancesRequestOrderBy! = {name: ASC}
  chainIds: [ChainId!]!
}

input UserBalancesRequestOrderBy @oneOf {
  name: OrderDirection
  supplyApy: OrderDirection
  balance: OrderDirection
}

type UserBorrowItem {
  amount: Erc20Amount!
  paid: Erc20Amount!
  reserve: Reserve!
}

input UserBorrowsQueryRequest @oneOf {
  userSpoke: UserSpokeInput
  userPositionId: UserPositionId
}

input UserBorrowsRequest {
  query: UserBorrowsQueryRequest!
  orderBy: UserBorrowsRequestOrderBy! = {name: ASC}
}

input UserBorrowsRequestOrderBy @oneOf {
  name: OrderDirection
  balance: OrderDirection
  apy: OrderDirection
  paid: OrderDirection
}

input UserHistoryFilter @oneOf {
  spoke: SpokeInput
  chainIds: [ChainId!]
}

union UserHistoryItem = BorrowActivity | SupplyActivity | WithdrawActivity | RepayActivity | LiquidatedActivity | SwapActivity

input UserHistoryRequest {
  user: EvmAddress!
  chainId: ChainId!
  activityTypes: [ActivityType!]! = [BORROW, SUPPLY, WITHDRAW, REPAY]
  filter: UserHistoryFilter
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type UserPosition {
  id: UserPositionId!
  spoke: Spoke!
  user: EvmAddress!
  netApy: PercentValue!
  netCollateral: FiatAmountWithChange!
  netBalance: FiatAmountWithChange!
  totalCollateral: FiatAmountWithChange!
  totalSupplied: FiatAmountWithChange!
  totalDebt: FiatAmountWithChange!
  netSupplyApy: PercentValueWithChange!
  netBorrowApy: PercentValueWithChange!
  healthFactor: BigDecimalWithChange
  riskPremium: PercentValue!
  betterRiskPremium: PercentValue
  supplies: [UserSupplyItem!]!
  borrows: [UserBorrowItem!]!
}

scalar UserPositionId

input UserPositionRequest {
  id: UserPositionId!
  user: EvmAddress!
}

input UserPositionsRequest {
  user: EvmAddress!
  orderBy: UserPositionsRequestOrderBy!
  chainIds: [ChainId!]!
}

input UserPositionsRequestOrderBy @oneOf {
  created: OrderDirection
  balance: OrderDirection
  apy: OrderDirection
  healthFactor: OrderDirection
  netCollateral: OrderDirection
}

input UserSpokeInput {
  spoke: SpokeInput!
  user: EvmAddress!
}

type UserSummary {
  netBalance: FiatAmountWithChange!
  totalCollateral: FiatAmount!
  totalSupplied: FiatAmount!
  totalDebt: FiatAmount!
  netApy: PercentValue!
  netFeeEarned: FiatAmount!
  netPnl: FiatAmount!
  lowestHealthFactor: BigDecimal
}

input UserSummaryFilter @oneOf {
  spoke: SpokeInput
  chainIds: [ChainId!]
}

type UserSummaryHistoryItem {
  netBalance: FiatAmount!
  borrows: FiatAmount!
  supplies: FiatAmount!
  healthFactor: BigDecimal
  date: DateTime!
}

input UserSummaryHistoryRequest {
  user: EvmAddress!
  filter: UserSummaryFilter
  window: TimeWindow!
}

input UserSummaryRequest {
  user: EvmAddress!
  filter: UserSummaryFilter
}

input UserSuppliesQueryRequest @oneOf {
  userSpoke: UserSpokeInput
  userPositionId: UserPositionId
}

input UserSuppliesRequest {
  query: UserSuppliesQueryRequest!
  orderBy: UserSuppliesRequestOrderBy! = {name: ASC}
}

input UserSuppliesRequestOrderBy @oneOf {
  name: OrderDirection
  balance: OrderDirection
  apy: OrderDirection
  earned: OrderDirection
}

type UserSupplyItem {
  amount: Erc20Amount!
  earned: Erc20Amount!
  isCollateral: Boolean!
  reserve: Reserve!
}

type WithdrawActivity {
  id: String!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  amount: Erc20Amount!
}

input WithdrawRequest {
  reserve: ReserveInput!
  amount: ReserveAmountInput!
  sender: EvmAddress!
  onBehalfOf: EvmAddress!
}

type _Service {
  sdl: String
}