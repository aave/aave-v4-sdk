type APYSample {
  date: DateTime!
  avgRate: PercentNumber!
}

input ActivitiesRequest {
  query: ActivitiesRequestQuery!
  user: EvmAddress
  types: [ActivityType!]! = [BORROW, SUPPLY, WITHDRAW, REPAY, LIQUIDATED]
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

input ActivitiesRequestQuery @oneOf {
  hub: HubInput
  spoke: SpokeInput
  chainIds: [ChainId!]
  txHash: TxHashInput
}

union ActivityItem = BorrowActivity | SupplyActivity | WithdrawActivity | RepayActivity | LiquidatedActivity

enum ActivityType {
  BORROW
  SUPPLY
  WITHDRAW
  REPAY
  LIQUIDATED
}

scalar AlwaysTrue

input AmountInput @oneOf {
  """Exact amount"""
  exact: BigDecimal

  """Max amount"""
  max: AlwaysTrue
}

enum ApyMetric {
  HIGHEST
  LOWEST
  AVERAGE
}

type Asset {
  id: AssetId!
  token: Erc20Token!
  summary: AssetSummary!
  price(currency: Currency! = USD): FiatAmountWithChange!
}

input AssetBorrowHistoryRequest {
  token: Erc20Input!
  window: TimeWindow! = LAST_DAY
}

type AssetBorrowSample {
  date: DateTime!
  amount: DecimalNumber!
}

scalar AssetId

input AssetPriceHistoryRequest {
  token: Erc20Input!
  currency: Currency! = USD
  window: TimeWindow! = LAST_DAY
}

type AssetPriceSample {
  date: DateTime!
  price: BigDecimal!
}

input AssetRequest {
  query: AssetRequestQuery!
}

input AssetRequestQuery @oneOf {
  token: Erc20Input
  assetId: AssetId
}

type AssetSummary {
  totalSupplyCap: DecimalNumberWithChange!
  totalSupplied: DecimalNumberWithChange!
  totalSuppliable: DecimalNumberWithChange!
  totalBorrowCap: DecimalNumberWithChange!
  totalBorrowed: DecimalNumberWithChange!
  totalBorrowable: DecimalNumberWithChange!
  totalSuppliedFiat(currency: Currency! = USD): FiatAmountWithChange!
  totalBorrowedFiat(currency: Currency! = USD): FiatAmountWithChange!

  """The supply APY dependent on what you pass in for the `metric`"""
  supplyApy(metric: ApyMetric! = AVERAGE): PercentNumber!

  """The borrow APY dependent on what you pass in for the `metric`"""
  borrowApy(metric: ApyMetric! = AVERAGE): PercentNumber!
}

input AssetSupplyHistoryRequest {
  token: Erc20Input!
  window: TimeWindow! = LAST_DAY
}

type AssetSupplySample {
  date: DateTime!
  amount: DecimalNumber!
}

scalar BigDecimal

scalar BigInt

scalar BlockchainData

input BorrowAPYHistoryRequest {
  reserve: ReserveId!
  window: TimeWindow! = LAST_DAY
}

type BorrowActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  borrowed: Erc20Amount!
  chain: Chain!
}

input BorrowRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount supplying"""
  amount: ReserveAmountInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

input CancelIntentSwapInput {
  id: SwapId!
  signature: Signature!
}

union CancelSwapExecutionPlan = TransactionRequest | SwapCancelled

input CancelSwapRequest @oneOf {
  intent: CancelIntentSwapInput
  transaction: SwapId
}

type CancelSwapTypeDefinition {
  EIP712Domain: [TypeField!]!
  OrderCancellations: [TypeField!]!
}

type CancelSwapTypedData {
  types: CancelSwapTypeDefinition!
  primaryType: String!
  domain: DomainData!
  message: JSON!
}

type Chain {
  name: String!
  icon: String!
  chainId: ChainId!
  explorerUrl: String!
  isTestnet: Boolean!
  nativeWrappedToken: EvmAddress!
  nativeInfo: TokenInfo!
  nativeGateway: EvmAddress!
  signatureGateway: EvmAddress!
}

"""A supported blockchain chain ID"""
scalar ChainId

input ChainRequest {
  """The chain id"""
  chainId: ChainId!
}

enum ChainsFilter {
  TESTNET_ONLY
  MAINNET_ONLY
  ALL
}

enum Currency {
  USD
  GBP
  EUR
}

scalar Cursor

scalar DateTime

type DecimalNumber {
  """The on-chain representation of `value`, stored as an integer."""
  onChainValue: BigInt!

  """
  The number of decimals defining how many fractional digits the number supports.
  """
  decimals: Int!

  """The normalized value computed as `onChainValue / 10^decimals`."""
  value: BigDecimal!
}

type DecimalNumberWithChange {
  current: DecimalNumber!
  change(window: TimeWindow! = LAST_DAY): DecimalNumber!
}

type DomainData {
  name: String!
  version: String!
  chainId: ChainId!
  verifyingContract: EvmAddress!
}

input ERC20PermitSignature {
  """The signature for the erc721"""
  value: Signature!

  """The deadline for the erc721"""
  deadline: Int!
}

type Erc20Amount {
  """The value"""
  amount: DecimalNumber!

  """The fiat amount"""
  fiatAmount(currency: Currency! = USD): FiatAmount!

  """The fiat rate"""
  fiatRate(currency: Currency! = USD): DecimalNumber!
  isWrappedNative: Boolean!
  token: Erc20Token!
}

type Erc20ApprovalRequired {
  """The transaction requires an approval first"""
  transaction: TransactionRequest!

  """The reason for the approval"""
  reason: String!

  """The required amount missing to be able to do the original transaction"""
  requiredAmount: DecimalNumber!

  """The current allowance approved"""
  currentAllowance: DecimalNumber!

  """The transaction to send after the approval is complete"""
  originalTransaction: TransactionRequest!
}

input Erc20Input {
  """The token address"""
  address: EvmAddress!

  """The token chain id"""
  chainId: ChainId!
}

type Erc20Token {
  """The token address"""
  address: EvmAddress!

  """The chain its deployed to"""
  chain: Chain!

  """The ERC20 token info"""
  info: TokenInfo!

  """
  The protocol only deals with ERC20 this allows you to understand if
  the token is a wrapped native token to allow you to maybe change `WETH` > `ETH`
  on the display screen, or whatever you decide makes sense
  """
  isWrappedNativeToken: Boolean!

  """If permit is supported for the ERC20 token"""
  permitSupported: Boolean!
}

scalar EvmAddress

input ExchangeRateRequest {
  """The from criteria"""
  from: ExchangeRateRequestFrom!

  """The currency to get the result in"""
  to: Currency!

  """
  The date time to get the exchange rate at, if not provided the latest rate is returned
  """
  at: DateTime
}

input ExchangeRateRequestFrom @oneOf {
  """The currency"""
  fiat: Currency

  """The erc20 token"""
  erc20: Erc20Input

  """The native token"""
  native: ChainId
}

union ExecutionPlan = TransactionRequest | Erc20ApprovalRequired | PreContractActionRequired | InsufficientBalanceError

type FiatAmount {
  value: BigDecimal!
  name: String!
  symbol: String!
}

type FiatAmountValueVariation {
  current: FiatAmount!
  after: FiatAmount!
}

type FiatAmountWithChange {
  current: FiatAmount!
  change(window: TimeWindow! = LAST_DAY): PercentNumber!
}

input ForkTopUpErc20 {
  """The token address"""
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction
  """
  value: BigDecimal!
}

input ForkTopUpRequest {
  """The address you want the funds to be topped up against"""
  user: EvmAddress!

  """The erc20 information"""
  erc20: ForkTopUpErc20

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction
  """
  native: BigDecimal
}

type ForkTopUpResponse {
  message: String!

  """The tx hash of the newly created transaction"""
  txHash: String
}

input HasProcessedKnownTransactionRequest {
  """
  The operation types this is given to you on the TransactionRequest::operations
  """
  operations: [OperationType!]!

  """The tx hash"""
  txHash: TxHash!
}

type HealthFactorError {
  reason: String!
  current: BigDecimal
  after: BigDecimal
}

union HealthFactorResult = HealthFactorVariation | HealthFactorError

type HealthFactorVariation {
  current: BigDecimal
  after: BigDecimal
}

type HealthFactorWithChange {
  current: BigDecimal
  change(window: TimeWindow! = LAST_DAY): PercentNumber!
}

type Hub {
  """The id for the hub"""
  id: HubId!

  """The hub name"""
  name: String!

  """The hub address"""
  address: EvmAddress!

  """The chain the hub is deployed on"""
  chain: Chain!

  """The hub summary"""
  summary(currency: Currency! = USD): HubSummary!
}

type HubAsset {
  """The id for the hub asset"""
  id: HubAssetId!

  """The onchain asset id"""
  onchainAssetId: OnChainHubAssetId!

  """The hub"""
  hub: Hub!

  """The underlying token"""
  underlying: Erc20Token!

  """The hub asset summary"""
  summary: HubAssetSummary!

  """The hub asset settings"""
  settings: HubAssetSettings!
  userState: HubAssetUserState
}

scalar HubAssetId

type HubAssetSettings {
  """The fee receiver"""
  feeReceiver: EvmAddress!

  """The liquidity fee"""
  liquidityFee: PercentNumber!

  """The ir strategy"""
  irStrategy: EvmAddress!

  """The reinvestment strategy"""
  reinvestmentController: EvmAddress
}

type HubAssetSummary {
  """The supplied amount"""
  supplied: Erc20Amount!

  """The borrowed amount"""
  borrowed: Erc20Amount!

  """The available liquidity"""
  availableLiquidity: Erc20Amount!

  """The supply APY"""
  supplyApy: PercentNumber!

  """The borrow APY"""
  borrowApy: PercentNumber!

  """The net APY"""
  netApy: PercentNumber!

  """The utilization rate"""
  utilizationRate: PercentNumber!
}

type HubAssetUserState {
  """The hub asset balance"""
  balance: Erc20Amount!
}

input HubAssetsRequest {
  hub: HubInput!
  user: EvmAddress
  orderBy: HubAssetsRequestOrderBy! = {assetName: ASC}
}

input HubAssetsRequestOrderBy @oneOf {
  assetName: OrderDirection
  availableLiquidity: OrderDirection
  supplyApy: OrderDirection
  borrowApy: OrderDirection
}

scalar HubId

input HubInput {
  """The hub address"""
  address: EvmAddress!

  """The hub chain id"""
  chainId: ChainId!
}

input HubRequest {
  query: HubRequestQuery!
}

input HubRequestQuery @oneOf {
  hubInput: HubInput
  hubId: HubId
}

type HubSummary {
  """
  The total spoke reserves aggregated borrowed using this hub, showed in fiat as each asset has a different value
  """
  totalBorrowed: FiatAmount!

  """
  The total spoke reserves aggregated borrow caps using this hub, showed in fiat as each asset has a different value
  """
  totalBorrowCap: FiatAmount!

  """
  The total spoke reserves aggregated supplied using this hub, showed in fiat as each asset has a different value
  """
  totalSupplied: FiatAmount!

  """
  The total spoke reserves aggregated supply caps using this hub, showed in fiat as each asset has a different value
  """
  totalSupplyCap: FiatAmount!

  """
  The utilization rate"
  """
  utilizationRate: BigDecimal!
}

input HubTokenInput {
  chainId: ChainId!
  hub: EvmAddress!
  token: EvmAddress!
}

input HubsRequest {
  query: HubsRequestQuery!
  orderBy: HubsRequestOrderBy! = {name: ASC}
}

input HubsRequestOrderBy @oneOf {
  name: OrderDirection
  totalBorrowed: OrderDirection
  totalSupplied: OrderDirection
}

input HubsRequestQuery @oneOf {
  """Get back all the hubs which have one of the underlying tokens supplied"""
  tokens: [Erc20Input!]

  """Get back all the hubs based on the chain ids passed in"""
  chainIds: [ChainId!]
}

type InsufficientBalanceError {
  """The amount required to do the original transaction"""
  required: DecimalNumber!

  """The amount available in the wallet"""
  available: DecimalNumber!
}

"""A scalar that can represent any JSON value."""
scalar JSON

input LiquidatePositionDebtAmount @oneOf {
  """Exact amount"""
  exact: BigDecimal

  """The most you can liquidate"""
  max: AlwaysTrue
}

union LiquidatePositionExecutionPlan = TransactionRequest | Erc20ApprovalRequired | InsufficientBalanceError

input LiquidatePositionRequest {
  """The collateral reserve id"""
  collateral: ReserveId!

  """The debt reserve id"""
  debt: ReserveId!

  """The amount to liquidate"""
  amount: LiquidatePositionDebtAmount!

  """The person liquidating the position"""
  liquidator: EvmAddress!

  """The user to liquidate"""
  user: EvmAddress!

  """If you would like to receive shares over the asset"""
  receiveShares: Boolean! = false
}

type LiquidatedActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  collateralReserve: ReserveInfo!
  debtReserve: ReserveInfo!
  collateral: Erc20Amount!
  debt: Erc20Amount!
  liquidator: EvmAddress!
  chain: Chain!
}

type NativeAmount {
  """The native token"""
  token: NativeToken!

  """The value"""
  amount: DecimalNumber!

  """The fiat amount"""
  fiatAmount(currency: Currency! = USD): FiatAmount!

  """The fiat rate"""
  fiatRate(currency: Currency! = USD): DecimalNumber!
}

type NativeToken {
  info: TokenInfo!
  chain: Chain!
}

scalar OnChainHubAssetId

scalar OnChainReserveId

enum OperationType {
  SPOKE_BORROW
  SPOKE_REPAY
  SPOKE_SUPPLY
  SPOKE_WITHDRAW
  SPOKE_UPDATE_USER_RISK_PREMIUM
  SPOKE_SET_USER_USING_AS_COLLATERAL
  SPOKE_SET_USER_POSITION_MANAGER
  RENOUNCE_SPOKE_USER_POSITION_MANAGER
}

enum OrderDirection {
  ASC
  DESC
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedActivitiesResult {
  items: [ActivityItem!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedResultInfo {
  """The cursor to the previous page of results, if any."""
  prev: Cursor

  """The cursor to the next page of results, if any."""
  next: Cursor
}

type PaginatedSpokePositionManagerResult {
  items: [SpokePositionManger!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedSpokeUserPositionManagerResult {
  items: [SpokeUserPositionManager!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUserSwapsResult {
  items: [SwapStatus!]!
  pageInfo: PaginatedResultInfo!
}

type PercentNumber {
  """
  The on-chain representation of the percentage, stored in basis points (bps).
  """
  onChainValue: BigInt!

  """The number of decimals defining the precision of `bps`."""
  decimals: Int!

  """The percentage value where 1.0 represents 100%."""
  value: BigDecimal!

  """The human-friendly percentage value formatted for display."""
  normalized: BigDecimal!
}

type PercentNumberVariation {
  current: PercentNumber!
  after: PercentNumber!
}

type PercentNumberWithChange {
  current: PercentNumber!
  change(window: TimeWindow! = LAST_DAY): PercentNumber!
}

type PermitMessageData {
  owner: EvmAddress!
  spender: EvmAddress!
  value: BigInt!
  nonce: BigInt!
  deadline: Int!
}

input PermitRequest @oneOf {
  supply: SupplyPermitRequest
  repay: RepayPermitRequest
}

type PermitTypedDataResponse {
  types: TypeDefinition!
  primaryType: String!
  domain: DomainData!
  message: PermitMessageData!
}

type PreContractActionRequired {
  """The transaction requires a pre-contract action first"""
  transaction: TransactionRequest!

  """The reason for the pre-contract action"""
  reason: String!

  """The transaction to send after the approval is complete"""
  originalTransaction: TransactionRequest!
}

input PrepareLimitOrderSwapInput {
  quoteId: SwapQuoteId!
  newSellAmount: BigDecimal
  newBuyAmount: BigDecimal

  """Slippage in basis points"""
  newSlippage: BigDecimal
  newReceiver: EvmAddress
}

input PrepareMarketOrderSwapInput {
  chainId: ChainId!
  buy: TokenInput!
  sell: TokenInput!
  amount: BigDecimal!
  kind: SwapKind!
  user: EvmAddress!
  receiver: EvmAddress
}

input PrepareSwapCancelRequest {
  id: SwapId!
}

type PrepareSwapCancelResult {
  data: CancelSwapTypedData!
}

input PrepareSwapRequest @oneOf {
  market: PrepareMarketOrderSwapInput
  limit: PrepareLimitOrderSwapInput
}

union PrepareSwapResult = SwapByIntent | SwapByIntentWithApprovalRequired | SwapByTransaction | InsufficientBalanceError

input PreviewAction @oneOf {
  supply: SupplyRequest
  borrow: BorrowRequest
  repay: RepayRequest
  withdraw: WithdrawRequest
  setUserSupplyAsCollateral: SetUserSupplyAsCollateralRequest
}

input PreviewRequest {
  action: PreviewAction!
}

type PreviewUserPosition {
  id: UserPositionId!
  healthFactor: HealthFactorResult!
  riskPremium: PercentNumberVariation!

  """The net APY for one user position on a current spoke"""
  netApy: PercentNumberVariation!
  netCollateral(currency: Currency! = USD): FiatAmountValueVariation!
  netBalance(currency: Currency! = USD): FiatAmountValueVariation!
}

type Query {
  health: Boolean!
  chain(request: ChainRequest!): Chain
  chains(filter: ChainsFilter!): [Chain!]!

  """Generate EIP-712 typed data for EIP-2612 permit signature"""
  permitTypedData(request: PermitRequest!): PermitTypedDataResponse!

  """Get the exchange rate of tokens > currency or currency > currency"""
  exchangeRate(request: ExchangeRateRequest!): FiatAmount!
  asset(request: AssetRequest!): Asset
  assetSupplyHistory(request: AssetSupplyHistoryRequest!): [AssetSupplySample!]!
  assetBorrowHistory(request: AssetBorrowHistoryRequest!): [AssetBorrowSample!]!
  assetPriceHistory(request: AssetPriceHistoryRequest!): [AssetPriceSample!]!

  """Fetch a list of hubs depending on your search criteria"""
  hubs(request: HubsRequest!): [Hub!]!
  hub(request: HubRequest!): Hub
  hubAssets(request: HubAssetsRequest!): [HubAsset!]!
  reserve(request: ReserveRequest!): Reserve
  reserves(request: ReservesRequest!): [Reserve!]!
  supply(request: SupplyRequest!): ExecutionPlan!
  borrow(request: BorrowRequest!): ExecutionPlan!
  withdraw(request: WithdrawRequest!): ExecutionPlan!
  repay(request: RepayRequest!): ExecutionPlan!
  spokePositionManagers(request: SpokePositionManagersRequest!): PaginatedSpokePositionManagerResult!
  spokeUserPositionManagers(request: SpokeUserPositionManagersRequest!): PaginatedSpokeUserPositionManagerResult!
  setSpokeUserPositionManager(request: SetSpokeUserPositionManagerRequest!): TransactionRequest!
  renounceSpokeUserPositionManager(request: RenounceSpokeUserPositionManagerRequest!): TransactionRequest!
  setUserSupplyAsCollateral(request: SetUserSupplyAsCollateralRequest!): TransactionRequest!
  liquidatePosition(request: LiquidatePositionRequest!): LiquidatePositionExecutionPlan!
  updateUserRiskPremium(request: UpdateUserRiskPremiumRequest!): TransactionRequest!
  updateUserDynamicConfig(request: UpdateUserDynamicConfigRequest!): TransactionRequest!
  preview(request: PreviewRequest!): PreviewUserPosition!
  borrowApyHistory(request: BorrowAPYHistoryRequest!): [APYSample!]!
  supplyApyHistory(request: SupplyAPYHistoryRequest!): [APYSample!]!
  spoke(request: SpokeRequest!): Spoke

  """Lists all spokes"""
  spokes(request: SpokesRequest!): [Spoke!]!

  """
  Get the user balances for the protocol
  This will only return assets that can be used on the protocol
  """
  userBalances(request: UserBalancesRequest!): [UserBalance!]!
  userBorrows(request: UserBorrowsRequest!): [UserBorrowItem!]!
  userSummary(request: UserSummaryRequest!): UserSummary!
  userSummaryHistory(request: UserSummaryHistoryRequest!): [UserSummaryHistoryItem!]!
  userPositions(request: UserPositionsRequest!): [UserPosition!]!
  userPosition(request: UserPositionRequest!): UserPosition
  userSupplies(request: UserSuppliesRequest!): [UserSupplyItem!]!

  """
  This lets you know the API has processed the known transaction hash, as the API uses caching to make things as fast
  as possible, it has an invalidation task, so sometimes if the receipt is complete, we may still (rarely) serve
  old data for 100-200ms longer, it's best to query after you got the receipt to be told that it is ready to go.
  Note the invalidation is very quick, and most of the time it's present even before your receipt is returned this is to
  cater for the race condition.
  """
  hasProcessedKnownTransaction(request: HasProcessedKnownTransactionRequest!): Boolean!
  activities(request: ActivitiesRequest!): PaginatedActivitiesResult!
  swapQuote(request: SwapQuoteRequest!): SwapQuote!
  prepareSwap(request: PrepareSwapRequest!): PrepareSwapResult!
  swap(request: SwapRequest!): SwapExecutionPlan!
  swapStatus(request: SwapStatusRequest!): SwapStatus!
  userSwaps(request: UserSwapsRequest!): PaginatedUserSwapsResult!
  prepareSwapCancel(request: PrepareSwapCancelRequest!): PrepareSwapCancelResult!
  cancelSwap(request: CancelSwapRequest!): CancelSwapExecutionPlan!
  swappableTokens(request: SwappableTokensRequest!): [Token!]!

  """Top up a balance for a user or yourself on the fork"""
  forkTopUp(request: ForkTopUpRequest!): ForkTopUpResponse!
}

input RenounceSpokeUserPositionManagerRequest {
  """The spoke"""
  spoke: SpokeInput!

  """The address to remove as a position manager"""
  manager: EvmAddress!

  """The address to remove `manager` as position manager"""
  managing: EvmAddress!
}

type RepayActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  repaid: Erc20Amount!
  chain: Chain!
}

input RepayAmountInputWithPermit @oneOf {
  """The native amount"""
  native: AmountInput

  """The erc20 amount input"""
  erc20: RepayErc20AmountInputWithPermit
}

input RepayErc20AmountInputWithPermit {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: AmountInput!

  """
  The signed ERC20 permit message to operate on the relevant token without a need for an ERC20 Approval transaction.
  """
  permitSig: ERC20PermitSignature
}

input RepayPermitRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount repaying"""
  amount: AmountInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

input RepayRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount repaying"""
  amount: RepayAmountInputWithPermit!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

type Reserve {
  id: ReserveId!
  onChainId: OnChainReserveId!
  borrowCap: BigDecimal!
  supplyCap: BigDecimal!
  chain: Chain!
  summary: ReserveSummary!
  settings: ReserveSettings!
  status: ReserveStatus!
  canBorrow: Boolean!
  canSupply: Boolean!
  canUseAsCollateral: Boolean!
  userState: ReserveUserState
  asset: HubAsset!
  spoke: Spoke!
}

input ReserveAmountInput @oneOf {
  """The native amount"""
  native: BigDecimal

  """The erc20 amount input"""
  erc20: ReserveErc20AmountInput
}

input ReserveAmountInputWithPermit @oneOf {
  """The native amount"""
  native: BigDecimal

  """The erc20 amount input"""
  erc20: ReserveErc20AmountInputWithPermit
}

input ReserveErc20AmountInput {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: BigDecimal!
}

input ReserveErc20AmountInputWithPermit {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: BigDecimal!

  """
  The signed ERC20 permit message to operate on the relevant token without a need for an ERC20 Approval transaction.
  """
  permitSig: ERC20PermitSignature
}

scalar ReserveId

type ReserveInfo {
  id: ReserveId!
  asset: HubAsset!
}

input ReserveRequest {
  """The reserve id"""
  reserve: ReserveId!

  """
  The user who is doing the query (this injects user state into some of the return objects)
  """
  user: EvmAddress
}

type ReserveSettings {
  collateralFactor: PercentNumber!
  maxLiquidationBonus: PercentNumber!
  collateralRisk: PercentNumber!
  borrowable: Boolean!
  collateral: Boolean!
  suppliable: Boolean!
}

type ReserveStatus {
  frozen: Boolean!
  paused: Boolean!
  active: Boolean!
}

type ReserveSummary {
  supplied: Erc20Amount!
  borrowed: Erc20Amount!
  supplyApy: PercentNumber!
  borrowApy: PercentNumber!
}

type ReserveUserState {
  balance: Erc20Amount!
  suppliable: Erc20Amount!
  borrowable: Erc20Amount!
  borrowApy: PercentNumber!
}

input ReservesRequest {
  """The reserve's request query"""
  query: ReservesRequestQuery!

  """
  The user who is doing the query (this injects user state into some of the return objects)
  """
  user: EvmAddress

  """The reserve's filter"""
  filter: ReservesRequestFilter! = ALL

  """The reserve's order by"""
  orderBy: ReservesRequestOrderBy! = {assetName: ASC}
}

enum ReservesRequestFilter {
  SUPPLY
  BORROW
  ALL
}

input ReservesRequestOrderBy @oneOf {
  assetName: OrderDirection
  userBalance: OrderDirection
  supplyApy: OrderDirection
  supplyAvailable: OrderDirection
  borrowApy: OrderDirection
  borrowAvailable: OrderDirection
  collateralFactor: OrderDirection
}

input ReservesRequestQuery @oneOf {
  """Get all the reserves for a spoke"""
  spoke: SpokeInput

  """Get all the reserves with underlying tokens"""
  tokens: [Erc20Input!]

  """Get all the reserves on a hub for an underlying"""
  hubToken: HubTokenInput

  """Get all the reserves on a list of chains"""
  chainIds: [ChainId!]

  """Get all the reserves for a spoke for an underlying"""
  spokeToken: SpokeTokenInput

  """Get all tokens on a hub"""
  hub: HubInput

  """Get all the reserves on based on user position id"""
  userPositionId: UserPositionId
}

input SetSpokeUserPositionManagerRequest {
  """The spoke"""
  spoke: SpokeInput!

  """The address to become the position manager"""
  manager: EvmAddress!

  """Approve or remove the manager"""
  approve: Boolean!

  """The user to set the position `manager` for"""
  user: EvmAddress!

  """The signature"""
  signature: ERC20PermitSignature
}

input SetUserSupplyAsCollateralRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """If you want to enable the collateral or disable"""
  enableCollateral: Boolean!
}

scalar Signature

type Spoke {
  """The id for the spoke"""
  id: SpokeId!

  """The spoke name (offchain)"""
  name: String!

  """The spoke address"""
  address: EvmAddress!

  """The spoke chain"""
  chain: Chain!
}

scalar SpokeId

input SpokeInput {
  """The address of the spoke"""
  address: EvmAddress!

  """The chain id the spoke is deployed to"""
  chainId: ChainId!
}

input SpokePositionManagersRequest {
  spoke: SpokeInput!
  includeInactive: Boolean
  pageSize: PageSize!
  cursor: Cursor
}

type SpokePositionManger {
  name: String!
  address: EvmAddress!
  active: Boolean!
}

input SpokeRequest {
  """The spoke request query"""
  query: SpokeRequestQuery!
}

input SpokeRequestQuery {
  """Spoke lookup parameters"""
  spoke: SpokeInput!
}

input SpokeTokenInput {
  """The spoke address"""
  spoke: EvmAddress!

  """The token"""
  token: EvmAddress!

  """The chain id"""
  chainId: ChainId!
}

type SpokeUserPositionManager {
  name: String!
  address: EvmAddress!
  approvedOn: DateTime!
  active: Boolean!
}

input SpokeUserPositionManagersRequest {
  spoke: SpokeInput!
  user: EvmAddress!
  pageSize: PageSize!
  cursor: Cursor
}

input SpokesRequest {
  query: SpokesRequestQuery!
}

input SpokesRequestQuery @oneOf {
  """
  The hub address and chain id
  Get all the spokes which hubs are linked to a spoke reserve
  """
  hub: HubInput

  """
  The chain ids
  Get all the spokes which are on the list of chain ids
  """
  chainIds: [ChainId!]
}

input SupplyAPYHistoryRequest {
  reserve: ReserveId!
  window: TimeWindow! = LAST_DAY
}

type SupplyActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  supplied: Erc20Amount!
  chain: Chain!
}

input SupplyPermitRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount supplying"""
  amount: ReserveErc20AmountInput!

  """If you wish to enable collateral with it meaning you can borrow"""
  enableCollateral: Boolean! = true

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

input SupplyRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount supplying"""
  amount: ReserveAmountInputWithPermit!

  """If you wish to enable collateral with it meaning you can borrow"""
  enableCollateral: Boolean! = true

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

type SwapApprovalRequired {
  approval: TransactionRequest!
  originalTransaction: SwapTransactionRequest!
}

type SwapByIntent {
  quote: SwapQuote!
  data: SwapByIntentTypedData!
}

input SwapByIntentInput {
  quoteId: SwapQuoteId!
  signature: Signature!
}

type SwapByIntentTypeDefinition {
  EIP712Domain: [TypeField!]!
  Order: [TypeField!]!
}

type SwapByIntentTypedData {
  types: SwapByIntentTypeDefinition!
  primaryType: String!
  domain: DomainData!
  message: JSON!
}

type SwapByIntentWithApprovalRequired {
  quote: SwapQuote!
  approval: TransactionRequest!
  data: SwapByIntentTypedData!
}

type SwapByTransaction {
  quote: SwapQuote!
}

type SwapCancelled {
  createdAt: DateTime!
  cancelledAt: DateTime
  explorerLink: String!
}

union SwapExecutionPlan = SwapTransactionRequest | SwapApprovalRequired | InsufficientBalanceError | SwapReceipt

type SwapExpired {
  createdAt: DateTime!
  expiredAt: DateTime!
  explorerLink: String!
}

type SwapFulfilled {
  txHash: String!
  desiredSell: TokenAmount!
  desiredBuy: TokenAmount!
  sold: TokenAmount!
  bought: TokenAmount!
  createdAt: DateTime!
  fulfilledAt: DateTime!
  explorerLink: String!
  refundTxHash: TxHash
}

scalar SwapId

enum SwapKind {
  BUY
  SELL
}

type SwapOpen {
  swapId: SwapId!
  createdAt: DateTime!
  deadline: DateTime!
  explorerLink: String!
  desiredSell: TokenAmount!
  desiredBuy: TokenAmount!
}

type SwapPendingSignature {
  createdAt: DateTime!
  deadline: DateTime!
  explorerLink: String!
}

type SwapQuote {
  quoteId: SwapQuoteId!
  suggestedSlippage: PercentNumber!
  desiredSell: TokenAmount!
  desiredBuy: TokenAmount!
  costs: SwapQuoteCosts!

  """Minimum received amount after all costs and slippage"""
  minimumReceived: TokenAmount!
}

type SwapQuoteCosts {
  """Network and provider costs"""
  networkCosts: TokenAmount!

  """Aave partner fee amount"""
  partnerFee: TokenAmount!
}

scalar SwapQuoteId

input SwapQuoteRequest {
  chainId: ChainId!
  buy: TokenInput!
  sell: TokenInput!
  amount: BigDecimal!
  kind: SwapKind
  from: EvmAddress!
  receiver: EvmAddress
}

type SwapReceipt {
  id: SwapId!
  createdAt: DateTime!
  explorerLink: String!
}

input SwapRequest @oneOf {
  intent: SwapByIntentInput
  transaction: SwapWithTransactionInput
}

union SwapStatus = SwapOpen | SwapPendingSignature | SwapCancelled | SwapExpired | SwapFulfilled

enum SwapStatusFilter {
  CANCELLED
  EXPIRED
  FULFILLED
  OPEN
  PENDING_SIGNATURE
}

input SwapStatusRequest {
  id: SwapId!
}

type SwapTransactionRequest {
  transaction: TransactionRequest!
  orderReceipt: SwapReceipt!
}

input SwapWithTransactionInput {
  quoteId: SwapQuoteId!
  permitSig: Signature

  """
  Whether the swap order creator is a smart contract wallet. If not provided, it will be inferred following the ERC-1271 standard.
  """
  isSenderSmartContractWallet: Boolean
}

input SwappableTokenInput @oneOf {
  native: ChainId
  erc20: Erc20Input
}

input SwappableTokensRequest {
  query: SwappableTokensRequestQuery
}

input SwappableTokensRequestQuery @oneOf {
  chainIds: [ChainId!]
  from: SwappableTokenInput
  to: SwappableTokenInput
}

enum TimeWindow {
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  LAST_SIX_MONTHS
  LAST_YEAR
  ALL
}

union Token = NativeToken | Erc20Token

union TokenAmount = NativeAmount | Erc20Amount

type TokenInfo {
  """The token name"""
  name: String!

  """The token symbol"""
  symbol: String!

  """The token icon"""
  icon: String!

  """The token decimals"""
  decimals: Int!
}

input TokenInput @oneOf {
  """Native token"""
  native: AlwaysTrue

  """The erc20 address"""
  erc20: EvmAddress
}

type TransactionRequest {
  to: EvmAddress!
  from: EvmAddress!
  data: BlockchainData!
  value: BigInt!
  chainId: ChainId!
  operations: [OperationType!]
}

scalar TxHash

input TxHashInput {
  txHash: TxHash!
  chainId: ChainId!
}

type TypeDefinition {
  EIP712Domain: [TypeField!]!
  Permit: [TypeField!]!
}

type TypeField {
  name: String!
  type: String!
}

input UpdateUserDynamicConfigRequest {
  """The spoke"""
  spoke: SpokeInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """If not supplied, this will use `sender` which is the normal route"""
  onBehalfOf: EvmAddress
}

input UpdateUserRiskPremiumRequest {
  """The spoke"""
  spoke: SpokeInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """If not supplied, this will use `sender` which is the normal route"""
  onBehalfOf: EvmAddress
}

type UserBalance {
  """The user balance id"""
  id: UserBalanceId!

  """The token info"""
  info: TokenInfo!

  """The balances across chains it will be 1 item per chain"""
  balances: [TokenAmount!]!

  """The total amount summed across all balances"""
  totalAmount: DecimalNumber!

  """The total fiat amount summed across all balances"""
  fiatAmount(currency: Currency! = USD): FiatAmount!

  """The supply APY dependent on what you pass in for the `metric`"""
  supplyApy(metric: ApyMetric! = HIGHEST): PercentNumber!

  """The borrow APY dependent on what you pass in for the `metric`"""
  borrowApy(metric: ApyMetric! = HIGHEST): PercentNumber!
}

scalar UserBalanceId

input UserBalancesByChains {
  """List of chains"""
  chainIds: [ChainId!]!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesByHub {
  """The hub address"""
  address: EvmAddress!

  """The hub chain id"""
  chainId: ChainId!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesBySpoke {
  """The spoke address"""
  address: EvmAddress!

  """The chain id the spoke is deployed to"""
  chainId: ChainId!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesByUserPosition {
  """The user position id"""
  userPositionId: UserPositionId!

  """
  The type of reserve to use when determine the tokens to retrieve balances for
  """
  byReservesType: ReservesRequestFilter! = ALL
}

input UserBalancesRequest {
  """The user to get the balance for"""
  user: EvmAddress!

  """The order by clause - defaults to the highest USD value"""
  orderBy: UserBalancesRequestOrderBy! = {balance: DESC}

  """The user balance filter"""
  filter: UserBalancesRequestFilter!

  """If you want to include 0 balances in the return list"""
  includeZeroBalances: Boolean! = false
}

input UserBalancesRequestFilter @oneOf {
  """The balances for the tokens on the specified chains"""
  chains: UserBalancesByChains

  """The balances for the tokens of hub assets on a given hub"""
  hub: UserBalancesByHub

  """The balances for the tokens of reserves attached to a spoke"""
  spoke: UserBalancesBySpoke

  """The balances for the swappable tokens"""
  swappable: SwappableTokensRequestQuery

  """
  The balances for the tokens of the spoke associated with the given user position
  """
  userPosition: UserBalancesByUserPosition
}

input UserBalancesRequestOrderBy @oneOf {
  """The name of the token"""
  name: OrderDirection

  """The balance of the token"""
  balance: OrderDirection
}

type UserBorrowItem {
  """The user borrow item id"""
  id: UserBorrowItemId!

  """The reserve borrowed from"""
  reserve: Reserve!

  """The amount borrowed on this reserve"""
  principal: Erc20Amount!

  """The overall debt including accrued interests"""
  debt: Erc20Amount!

  """The interest incurred on the loan"""
  interest: Erc20Amount!

  """
  When the borrow was created.
  This is null if they have no supply item, for
  example, when using include_zero_balances this comes
  back as principal and debt as 0
  """
  createdAt: DateTime
}

scalar UserBorrowItemId

input UserBorrowsQueryRequest @oneOf {
  userSpoke: UserSpokeInput
  userToken: UserToken
  userPositionId: UserPositionId
  userChains: UserChains
}

input UserBorrowsRequest {
  query: UserBorrowsQueryRequest!
  orderBy: UserBorrowsRequestOrderBy! = {amount: DESC}

  """If you wish to include zero balances in the results"""
  includeZeroBalances: Boolean! = false
}

input UserBorrowsRequestOrderBy @oneOf {
  assetName: OrderDirection
  created: OrderDirection
  amount: OrderDirection
  apy: OrderDirection
}

input UserChains {
  user: EvmAddress!
  chainIds: [ChainId!]!
}

type UserPosition {
  """The user holding this position"""
  user: EvmAddress!
  createdAt: DateTime!

  """The user position ID"""
  id: UserPositionId!
  totalSupplied(currency: Currency! = USD): FiatAmountWithChange!

  """
  Total collateral which is the full some of the assets supplied which are enabled as collateral
  """
  totalCollateral(currency: Currency! = USD): FiatAmountWithChange!

  """Total debt which is the total amount borrowed plus the accrued premium"""
  totalDebt(currency: Currency! = USD): FiatAmountWithChange!

  """The net balance which is `total_supplied` - `borrows`"""
  netBalance(currency: Currency! = USD): FiatAmountWithChange!

  """The net collateral which is `totalCollateral` - `totalDebt`"""
  netCollateral(currency: Currency! = USD): FiatAmountWithChange!
  netApy: PercentNumber!
  netSupplyApy: PercentNumberWithChange!
  netBorrowApy: PercentNumberWithChange!
  healthFactor: HealthFactorWithChange!
  betterRiskPremium: PercentNumber
  riskPremium: PercentNumber!
  netBalancePercentChange(window: TimeWindow! = LAST_DAY): PercentNumber!
  spoke: Spoke!
  averageCollateralFactor: PercentNumber!
}

scalar UserPositionId

input UserPositionRequest @oneOf {
  userSpoke: UserSpokeInput
  id: UserPositionId
}

input UserPositionsRequest {
  """The user to get the positions for"""
  user: EvmAddress!

  """The filter for the user position"""
  filter: UserPositionsRequestFilter!

  """The ordering for the positions"""
  orderBy: UserPositionsRequestOrderBy! = {created: ASC}
}

input UserPositionsRequestFilter @oneOf {
  tokens: [Erc20Input!]
  chainIds: [ChainId!]
}

input UserPositionsRequestOrderBy @oneOf {
  created: OrderDirection
  balance: OrderDirection
  netApy: OrderDirection
  healthFactor: OrderDirection
  netCollateral: OrderDirection
}

input UserSpokeInput {
  spoke: SpokeInput!
  user: EvmAddress!
}

type UserSummary {
  totalPositions: Int!

  """Net balance = supply - debt"""
  netBalance(currency: Currency! = USD): FiatAmountWithChange!

  """Total supply where is_collateral is true"""
  totalCollateral(currency: Currency! = USD): FiatAmount!

  """Total supplied across all positions"""
  totalSupplied(currency: Currency! = USD): FiatAmount!

  """Total debt across all positions"""
  totalDebt(currency: Currency! = USD): FiatAmount!

  """
  Net APY = (Σ (supplied_amount_i * supply_apy_i) - Σ (borrowed_amount_j * borrow_apy_j)) / (Σ supplied_amount_i)
  """
  netApy: PercentNumber!

  """Interest earned (net fee earned)"""
  netFeeEarned: FiatAmount!

  """Lowest health factor across all positions"""
  lowestHealthFactor: BigDecimal
}

input UserSummaryFilter @oneOf {
  spoke: SpokeInput
  chainIds: [ChainId!]
}

type UserSummaryHistoryItem {
  healthFactor: BigDecimal
  date: DateTime!

  """The aggregated net balance for the time period"""
  netBalance(currency: Currency! = USD): FiatAmount!

  """The aggregated borrows for the time period"""
  borrows(currency: Currency! = USD): FiatAmount!

  """The aggregated supplies for the time period"""
  supplies(currency: Currency! = USD): FiatAmount!
}

input UserSummaryHistoryRequest {
  user: EvmAddress!
  filter: UserSummaryFilter
  window: TimeWindow! = LAST_DAY
}

input UserSummaryRequest {
  user: EvmAddress!
  filter: UserSummaryFilter
}

input UserSuppliesQueryRequest @oneOf {
  userSpoke: UserSpokeInput
  userToken: UserToken
  userPositionId: UserPositionId
  userChains: UserChains
}

input UserSuppliesRequest {
  query: UserSuppliesQueryRequest!
  orderBy: UserSuppliesRequestOrderBy! = {amount: DESC}

  """If you wish to include zero balances in the results"""
  includeZeroBalances: Boolean! = false
}

input UserSuppliesRequestOrderBy @oneOf {
  assetName: OrderDirection
  created: OrderDirection
  amount: OrderDirection
  apy: OrderDirection
}

type UserSupplyItem {
  """The user supply item id"""
  id: UserSupplyItemId!

  """The reserve supplied to"""
  reserve: Reserve!

  """The amount supplied to this reserve"""
  principal: Erc20Amount!

  """The overall amount you can withdraw, including accrued interests"""
  withdrawable: Erc20Amount!

  """The interest amount earned on supplying"""
  interest: Erc20Amount!

  """If this supply is used as collateral"""
  isCollateral: Boolean!

  """
  When the supply was created.
  This is null if they have no supply item, for
  example, when using include_zero_balances this comes
  back as principal and withdrawable as 0
  """
  createdAt: DateTime
}

scalar UserSupplyItemId

input UserSwapsRequest {
  chainId: ChainId!
  user: EvmAddress!
  filterBy: [SwapStatusFilter!]
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

input UserToken {
  user: EvmAddress!
  token: Erc20Input!
}

type WithdrawActivity {
  id: ID!
  user: EvmAddress!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  withdrawn: Erc20Amount!
  chain: Chain!
}

input WithdrawRequest {
  """The reserve id"""
  reserve: ReserveId!

  """The amount withdrawing"""
  amount: WithdrawReserveAmountInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!
}

input WithdrawReserveAmountInput @oneOf {
  """The native amount"""
  native: AmountInput

  """The erc20 amount input"""
  erc20: AmountInput
}