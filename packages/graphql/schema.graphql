type APYSample {
  date: DateTime!
  avgRate: PercentValue!
}

enum ActivityType {
  BORROW
  SUPPLY
  WITHDRAW
  REPAY
  LIQUIDATED
  SWAP
}

scalar AlwaysTrue

input AmountInput @oneOf {
  """Exact amount"""
  exact: BigDecimal

  """Max amount"""
  max: AlwaysTrue
}

type ApprovalRequired {
  """The transaction requires an approval first"""
  approval: TransactionRequest!
  reason: String!

  """The required amount missing to be able to do the original transaction"""
  requiredAmount: DecimalValue!

  """The current allowance approved"""
  currentAllowance: DecimalValue!

  """The transaction to send after the approval is complete"""
  originalTransaction: TransactionRequest!
}

enum ApyMetric {
  HIGHEST
  LOWEST
}

scalar AssetId

scalar BigDecimal

scalar BigInt

scalar BlockchainData

input BorrowAPYHistoryRequest {
  spoke: SpokeInput!
  reserve: ReserveId!
  window: TimeWindow!
}

type BorrowActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  amount: Erc20Amount!
}

input BorrowRequest {
  """The reserve"""
  reserve: ReserveInput!

  """The amount supplying"""
  amount: ReserveAmountInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """
  If not supplied, this will use `sender` which is the normal route - you can only use on
  `onBehalfOf` if you're a position manager for that user
  """
  onBehalfOf: EvmAddress
}

input CancelIntentSwapInput {
  id: SwapId!
  signature: Signature!
}

union CancelSwapExecutionPlan = TransactionRequest | SwapCancelled

input CancelSwapRequest @oneOf {
  intent: CancelIntentSwapInput
  transaction: SwapId
}

type CancelSwapTypeDefinition {
  EIP712Domain: [TypeField!]!
  OrderCancellations: [TypeField!]!
}

type CancelSwapTypedData {
  types: CancelSwapTypeDefinition!
  primaryType: String!
  domain: DomainData!
  message: JSON!
}

type Chain {
  name: String!
  icon: String!
  chainId: ChainId!
  explorerUrl: String!
  isTestnet: Boolean!
  nativeWrappedToken: EvmAddress!
  nativeInfo: TokenInfo!
}

"""A supported blockchain chain ID"""
scalar ChainId

enum ChainsFilter {
  TESTNET_ONLY
  MAINNET_ONLY
  ALL
}

enum Currency {
  USD
  GBP
  EUR
}

scalar Cursor

scalar DateTime

type DecimalValue {
  """
  The raw value before any formatting (should be used if you want to do any math)
  """
  raw: BigInt!

  """The decimals"""
  decimals: Int!

  """The formatted value which is {raw} / 1e{decimals}"""
  formatted: BigDecimal!
}

type DomainData {
  name: String!
  version: String!
  chainId: ChainId!
  verifyingContract: EvmAddress!
}

input ERC20PermitSignature {
  """The signature for the erc721"""
  value: Signature!

  """The deadline for the erc721"""
  deadline: Int!
}

type Erc20Amount {
  """The value"""
  value: DecimalValue!
  fiatAmount(currency: Currency! = USD): FiatAmount!
  fiatRate(currency: Currency! = USD): DecimalValue!
  isWrappedNative: Boolean!
  token: Erc20Token!
}

input Erc20Input {
  """The token address"""
  address: EvmAddress!

  """The token chain id"""
  chainId: ChainId!
}

type Erc20Token {
  """The token address"""
  address: EvmAddress!

  """The chain its deployed to"""
  chain: Chain!

  """The ERC20 token info"""
  info: TokenInfo!

  """
  The protocol only deals with ERC20 this allows you to understand if
  the token is a wrapped native token to allow you to maybe change `WETH` > `ETH`
  on the display screen, or whatever you decide makes sense
  """
  isWrappedNativeToken: Boolean!

  """If permit is supported for the ERC20 token"""
  permitSupported: Boolean!
}

scalar EvmAddress

input ExchangeRateRequest {
  """The from criteria"""
  from: ExchangeRateRequestFrom!

  """The currency to get the result in"""
  to: Currency!
}

input ExchangeRateRequestFrom @oneOf {
  """The currency"""
  fiat: Currency

  """The erc20 token"""
  erc20: Erc20Input

  """The native token"""
  native: ChainId
}

union ExecutionPlan = TransactionRequest | ApprovalRequired | InsufficientBalanceError

type FiatAmount {
  value: BigDecimal!
  name: String!
  symbol: String!
}

type FiatAmountValueVariation {
  current: FiatAmount!
  after: FiatAmount!
}

type FiatAmountWithChange {
  amount: FiatAmount!
  change(window: TimeWindow! = LAST_DAY): PercentValue!
}

input ForkTopUpErc20 {
  """The token address"""
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction
  """
  value: BigDecimal!
}

input ForkTopUpRequest {
  """The address you want the funds to be topped up against"""
  user: EvmAddress!

  """The erc20 information"""
  erc20: ForkTopUpErc20

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction
  """
  native: BigDecimal
}

type ForkTopUpResponse {
  message: String!

  """The tx hash of the newly created transaction"""
  txHash: String
}

input HasProcessedKnownTransactionRequest {
  """
  The operation types this is given to you on the TransactionRequest::operations
  """
  operations: [OperationType!]!

  """The tx hash"""
  txHash: TxHash!
}

type HealthFactorChange {
  value: BigDecimal
  change(window: TimeWindow! = LAST_DAY): PercentValue!
}

type HealthFactorVariation {
  current: BigDecimal
  after: BigDecimal
}

type Hub {
  """The hub name"""
  name: String!

  """The hub address"""
  address: EvmAddress!

  """The chain the hub is deployed on"""
  chain: Chain!

  """The hub summary"""
  summary(currency: Currency! = USD): HubSummary!
}

type HubAsset {
  """The asset id"""
  assetId: AssetId!

  """The hub"""
  hub: Hub!

  """The underlying token"""
  underlying: Erc20Token!

  """The hub asset summary"""
  summary: HubAssetSummary!

  """The hub asset settings"""
  settings: HubAssetSettings!
  userState: HubAssetUserState
}

type HubAssetSettings {
  """The fee receiver"""
  feeReceiver: EvmAddress!

  """The liquidity fee"""
  liquidityFee: PercentValue!

  """The ir strategy"""
  irStrategy: EvmAddress!

  """The reinvestment strategy"""
  reinvestmentController: EvmAddress
}

type HubAssetSummary {
  """The supplied amount"""
  supplied: BigDecimal!

  """The borrowed amount"""
  borrowed: BigDecimal!

  """The available liquidity"""
  availableLiquidity: BigDecimal!

  """The supply APY"""
  supplyApy: PercentValue!

  """The borrow APY"""
  borrowApy: PercentValue!

  """The net APY"""
  netApy: PercentValue!

  """The utilization rate"""
  utilizationRate: PercentValue!
}

type HubAssetUserState {
  """The hub asset balance"""
  balance: Erc20Amount!
}

input HubAssetsRequest {
  hub: EvmAddress!
  user: EvmAddress
  chainId: ChainId!
}

input HubInput {
  """The hub address"""
  address: EvmAddress!

  """The hub chain id"""
  chainId: ChainId!
}

input HubRequest {
  hub: EvmAddress!
  chainId: ChainId!
}

type HubSummary {
  """
  The total spoke reserves aggregated borrowed using this hub, showed in fiat as each asset has a different value
  """
  totalBorrowed: FiatAmount!

  """
  The total spoke reserves aggregated borrow caps using this hub, showed in fiat as each asset has a different value
  """
  totalBorrowCap: FiatAmount!

  """
  The total spoke reserves aggregated supplied using this hub, showed in fiat as each asset has a different value
  """
  totalSupplied: FiatAmount!

  """
  The total spoke reserves aggregated supply caps using this hub, showed in fiat as each asset has a different value
  """
  totalSupplyCap: FiatAmount!
}

input HubTokenInput {
  chainId: ChainId!
  hub: EvmAddress!
  token: EvmAddress!
}

input HubsRequest {
  query: HubsRequestQuery!
}

input HubsRequestQuery @oneOf {
  """Get back all the hubs which have one of the underlying tokens supplied"""
  tokens: [Erc20Input!]

  """Get back all the hubs based on the chain ids passed in"""
  chainIds: [ChainId!]
}

type InsufficientBalanceError {
  """The amount required to do the original transaction"""
  required: DecimalValue!

  """The amount available in the wallet"""
  available: DecimalValue!
}

"""A scalar that can represent any JSON value."""
scalar JSON

input LiquidatePositionDebtAmount @oneOf {
  """Exact amount"""
  exact: BigDecimal

  """The most you can liquidate"""
  max: AlwaysTrue
}

input LiquidatePositionRequest {
  """The spoke"""
  spoke: SpokeInput!

  """The collateral reserve id"""
  collateral: ReserveId!

  """The debt reserve id"""
  debt: ReserveId!

  """The amount to liquidate"""
  amount: LiquidatePositionDebtAmount!

  """The person liquidating the position"""
  liquidator: EvmAddress!

  """The user to liquidate"""
  user: EvmAddress!
}

type LiquidatedActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  collateralReserve: ReserveInfo!
  debtReserve: ReserveInfo!
  collateralAmount: Erc20Amount!
  debtAmount: Erc20Amount!
  liquidator: EvmAddress!
}

type NativeAmount {
  """The native token"""
  token: NativeToken!

  """The value"""
  value: DecimalValue!

  """The fiat amount"""
  fiatAmount(currency: Currency! = USD): FiatAmount!

  """The fiat rate"""
  fiatRate(currency: Currency! = USD): DecimalValue!
}

type NativeToken {
  info: TokenInfo!
  chain: Chain!
}

enum OperationType {
  SPOKE_BORROW
  SPOKE_REPAY
  SPOKE_SUPPLY
  SPOKE_WITHDRAW
  SPOKE_UPDATE_USER_RISK_PREMIUM
  SPOKE_SET_USER_USING_AS_COLLATERAL
  SPOKE_SET_USER_POSITION_MANAGER
  RENOUNCE_SPOKE_USER_POSITION_MANAGER
}

enum OrderDirection {
  ASC
  DESC
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedResultInfo {
  """The cursor to the previous page of results, if any."""
  prev: Cursor

  """The cursor to the next page of results, if any."""
  next: Cursor
}

type PaginatedSpokePositionManagerResult {
  items: [SpokePositionManger!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedSpokeUserPositionManagerResult {
  items: [SpokeUserPositionManager!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUserHistoryResult {
  items: [UserHistoryItem!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUserSwapsResult {
  items: [SwapStatus!]!
  pageInfo: PaginatedResultInfo!
}

type PercentValue {
  """The raw none normalized percentage (the value that lives onchain)"""
  raw: BigInt!

  """The decimals representing the precision of the onchain raw value"""
  decimals: Int!

  """The normalized percentage (1.0 = 100%)"""
  value: BigDecimal!

  """
  The human-readable formatted value you can render on a UI straight away.
  For example, this will turn `0.01232343` to `1.23`, it will always round to `2` decimal points.
  """
  formatted: BigDecimal!
}

type PercentValueVariation {
  current: PercentValue!
  after: PercentValue!
}

type PercentValueWithChange {
  amount: PercentValue!
  change(window: TimeWindow! = LAST_DAY): PercentValue!
}

type PermitMessageData {
  owner: EvmAddress!
  spender: EvmAddress!
  value: BigInt!
  nonce: BigInt!
  deadline: Int!
}

input PermitRequest @oneOf {
  supply: SupplyPermitRequest
  repay: RepayPermitRequest
}

type PermitTypedDataResponse {
  types: TypeDefinition!
  primaryType: String!
  domain: DomainData!
  message: PermitMessageData!
}

input PrepareLimitOrderSwapInput {
  quoteId: SwapQuoteId!
  newSellAmount: BigDecimal
  newBuyAmount: BigDecimal

  """Slippage in basis points"""
  newSlippage: BigDecimal
  newReceiver: EvmAddress
}

input PrepareMarketOrderSwapInput {
  chainId: ChainId!
  buy: TokenInput!
  sell: TokenInput!
  amount: BigDecimal!
  kind: SwapKind!
  user: EvmAddress!
  receiver: EvmAddress
}

input PrepareSwapCancelRequest {
  id: SwapId!
}

type PrepareSwapCancelResult {
  data: CancelSwapTypedData!
}

input PrepareSwapRequest @oneOf {
  market: PrepareMarketOrderSwapInput
  limit: PrepareLimitOrderSwapInput
}

union PrepareSwapResult = SwapByIntent | SwapByIntentWithApprovalRequired | SwapByTransaction | InsufficientBalanceError

input PreviewAction @oneOf {
  supply: SupplyRequest
  borrow: BorrowRequest
  repay: RepayRequest
  withdraw: WithdrawRequest
  setUserSupplyAsCollateral: SetUserSupplyAsCollateralRequest
}

input PreviewRequest {
  action: PreviewAction!
}

type PreviewUserPosition {
  id: UserPositionId!
  healthFactor: HealthFactorVariation
  riskPremium: PercentValueVariation!
  positionApy: PercentValueVariation!
  netApy: PercentValueVariation!
  netCollateral(currency: Currency! = USD): FiatAmountValueVariation!
  netBalance(currency: Currency! = USD): FiatAmountValueVariation!
}

type Query {
  health: Boolean!
  chains(filter: ChainsFilter!): [Chain!]!

  """Generate EIP-712 typed data for EIP-2612 permit signature"""
  permitTypedData(request: PermitRequest!): PermitTypedDataResponse!

  """Get the exchange rate of tokens > currency or currency > currency"""
  exchangeRate(request: ExchangeRateRequest!): FiatAmount!

  """Fetch a list of hubs depending on your search criteria"""
  hubs(request: HubsRequest!): [Hub!]!
  hub(request: HubRequest!): Hub
  hubAssets(request: HubAssetsRequest!): [HubAsset!]!
  reserves(request: ReservesRequest!): [Reserve!]!
  supply(request: SupplyRequest!): ExecutionPlan!
  borrow(request: BorrowRequest!): ExecutionPlan!
  withdraw(request: WithdrawRequest!): ExecutionPlan!
  repay(request: RepayRequest!): ExecutionPlan!
  spokePositionManagers(request: SpokePositionManagersRequest!): PaginatedSpokePositionManagerResult!
  spokeUserPositionManagers(request: SpokeUserPositionManagersRequest!): PaginatedSpokeUserPositionManagerResult!
  setSpokeUserPositionManager(request: SetSpokeUserPositionManagerRequest!): TransactionRequest!
  renounceSpokeUserPositionManager(request: RenounceSpokeUserPositionManagerRequest!): TransactionRequest!
  setUserSupplyAsCollateral(request: SetUserSupplyAsCollateralRequest!): TransactionRequest!
  liquidatePosition(request: LiquidatePositionRequest!): ExecutionPlan!
  updateUserRiskPremium(request: UpdateUserRiskPremiumRequest!): TransactionRequest!
  updateUserDynamicConfig(request: UpdateUserDynamicConfigRequest!): TransactionRequest!
  preview(request: PreviewRequest!): PreviewUserPosition!
  borrowApyHistory(request: BorrowAPYHistoryRequest!): [APYSample!]!
  supplyApyHistory(request: SupplyAPYHistoryRequest!): [APYSample!]!

  """Lists all spokes"""
  spokes(request: SpokesRequest!): [Spoke!]!

  """
  Get the user balances for the protocol
  This will only return assets that can be used on the protocol
  """
  userBalances(request: UserBalancesRequest!): [UserBalance!]!
  userBorrows(request: UserBorrowsRequest!): [UserBorrowItem!]!
  userHistory(request: UserHistoryRequest!): PaginatedUserHistoryResult!
  userSummary(request: UserSummaryRequest!): UserSummary!
  userSummaryHistory(request: UserSummaryHistoryRequest!): [UserSummaryHistoryItem!]!
  userPositions(request: UserPositionsRequest!): [UserPosition!]!
  userPosition(request: UserPositionRequest!): UserPosition
  userSupplies(request: UserSuppliesRequest!): [UserSupplyItem!]!

  """
  This lets you know the API has processed the known transaction hash, as the API uses caching to make things as fast
  as possible, it has an invalidation task, so sometimes if the receipt is complete, we may still (rarely) serve
  old data for 100-200ms longer, it's best to query after you got the receipt to be told that it is ready to go.
  Note the invalidation is very quick, and most of the time it's present even before your receipt is returned this is to
  cater for the race condition.
  """
  hasProcessedKnownTransaction(request: HasProcessedKnownTransactionRequest!): Boolean!
  swapQuote(request: SwapQuoteRequest!): SwapQuote!
  prepareSwap(request: PrepareSwapRequest!): PrepareSwapResult!
  swap(request: SwapRequest!): SwapExecutionPlan!
  swapStatus(request: SwapStatusRequest!): SwapStatus!
  userSwaps(request: UserSwapsRequest!): PaginatedUserSwapsResult!
  prepareSwapCancel(request: PrepareSwapCancelRequest!): PrepareSwapCancelResult!
  cancelSwap(request: CancelSwapRequest!): CancelSwapExecutionPlan!
  swappableTokens(request: SwappableTokensRequest!): [Token!]!

  """Top up a balance for a user or yourself on the fork"""
  forkTopUp(request: ForkTopUpRequest!): ForkTopUpResponse!
}

input RenounceSpokeUserPositionManagerRequest {
  """The spoke"""
  spoke: SpokeInput!

  """The address to remove as a position manager"""
  manager: EvmAddress!

  """The address to remove `manager` as position manager"""
  managing: EvmAddress!
}

type RepayActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  amount: Erc20Amount!
}

input RepayAmountInputWithPermit @oneOf {
  """The native amount"""
  native: AmountInput

  """The erc20 amount input"""
  erc20: RepayErc20AmountInputWithPermit
}

input RepayErc20AmountInputWithPermit {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: AmountInput!

  """
  The signed ERC20 permit message to operate on the relevant token without a need for an ERC20 Approval transaction.
  """
  permitSig: ERC20PermitSignature
}

input RepayPermitRequest {
  """The reserve"""
  reserve: ReserveInput!

  """The amount repaying"""
  amount: AmountInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """
  If not supplied, this will use `sender` which is the normal route - you can only use on
  `onBehalfOf` if you're a position manager for that user
  """
  onBehalfOf: EvmAddress
}

input RepayRequest {
  """The reserve"""
  reserve: ReserveInput!

  """The amount repaying"""
  amount: RepayAmountInputWithPermit!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """
  If not supplied, this will use `sender` which is the normal route - you can only use on
  `onBehalfOf` if you're a position manager for that user
  """
  onBehalfOf: EvmAddress
}

type Reserve {
  id: ReserveId!
  borrowCap: BigDecimal!
  supplyCap: BigDecimal!
  chain: Chain!
  summary: ReserveSummary!
  settings: ReserveSettings!
  status: ReserveStatus!
  canBorrow: Boolean!
  canSupply: Boolean!
  canUseAsCollateral: Boolean!
  userState: ReserveUserState
  asset: HubAsset!
  spoke: Spoke!
}

input ReserveAmountInput @oneOf {
  """The native amount"""
  native: BigDecimal

  """The erc20 amount input"""
  erc20: ReserveErc20AmountInput
}

input ReserveAmountInputWithPermit @oneOf {
  """The native amount"""
  native: BigDecimal

  """The erc20 amount input"""
  erc20: ReserveErc20AmountInputWithPermit
}

input ReserveErc20AmountInput {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: BigDecimal!
}

input ReserveErc20AmountInputWithPermit {
  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g., wei).
  """
  value: BigDecimal!

  """
  The signed ERC20 permit message to operate on the relevant token without a need for an ERC20 Approval transaction.
  """
  permitSig: ERC20PermitSignature
}

scalar ReserveId

type ReserveInfo {
  id: ReserveId!
  spoke: Spoke!
  chain: Chain!
  asset: HubAsset!
}

input ReserveInput {
  """The chain id"""
  chainId: ChainId!

  """The spoke address"""
  spoke: EvmAddress!

  """The reserve id"""
  reserveId: ReserveId!
}

type ReserveSettings {
  collateralFactor: PercentValue!
  maxLiquidationBonus: PercentValue!
  collateralRisk: PercentValue!
  borrowable: Boolean!
  collateral: Boolean!
}

type ReserveStatus {
  frozen: Boolean!
  paused: Boolean!
  active: Boolean!
}

type ReserveSummary {
  supplied: Erc20Amount!
  borrowed: Erc20Amount!
  supplyApy: PercentValue!
  borrowApy: PercentValue!
}

type ReserveUserState {
  balance: Erc20Amount!
  suppliable: Erc20Amount!
  borrowable: Erc20Amount!
  borrowApy: PercentValue!
}

input ReservesRequest {
  """The reserve's request query"""
  query: ReservesRequestQuery!

  """
  The user who is doing the query (this injects user state into some of the return objects)
  """
  user: EvmAddress

  """The reserve's filter"""
  filter: ReservesRequestFilter! = ALL

  """The reserve's order by"""
  orderBy: ReservesRequestOrderBy! = {assetName: ASC}
}

enum ReservesRequestFilter {
  SUPPLY
  BORROW
  ALL
}

input ReservesRequestOrderBy @oneOf {
  assetName: OrderDirection
  userBalance: OrderDirection
  supplyApy: OrderDirection
  borrowApy: OrderDirection
  collateralFactor: OrderDirection
}

input ReservesRequestQuery @oneOf {
  """Get all the reserves for a spoke"""
  spoke: SpokeInput

  """Get all the reserves with underlying tokens"""
  tokens: [Erc20Input!]

  """Get all the reserves on a hub for an underlying"""
  hubToken: HubTokenInput

  """Get all the reserves on a list of chains"""
  chainIds: [ChainId!]

  """Get all the reserves for a spoke for an underlying"""
  spokeToken: SpokeTokenInput

  """Get all tokens on a hub"""
  hub: HubInput
}

input SetSpokeUserPositionManagerRequest {
  """The spoke"""
  spoke: SpokeInput!

  """The address to become the position manager"""
  manager: EvmAddress!

  """Approve or remove the manager"""
  approve: Boolean!

  """The user to set the position `manager` for"""
  user: EvmAddress!

  """The signature"""
  signature: ERC20PermitSignature
}

input SetUserSupplyAsCollateralRequest {
  """The reserve input"""
  reserve: ReserveInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """
  If not supplied, this will use `sender` which is the normal route - you can only use on
  `onBehalfOf` if you're a position manager for that user
  """
  onBehalfOf: EvmAddress

  """If you want to enable the collateral or disable"""
  enableCollateral: Boolean!
}

scalar Signature

type Spoke {
  """The spoke name (offchain)"""
  name: String!

  """The spoke address"""
  address: EvmAddress!

  """The spoke chain"""
  chain: Chain!

  """The spoke config"""
  config: SpokeConfig!
}

type SpokeConfig {
  nativeGateway: EvmAddress!
  signatureGateway: EvmAddress!
}

input SpokeInput {
  """The address of the spoke"""
  address: EvmAddress!

  """The chain id the spoke is deployed to"""
  chainId: ChainId!
}

input SpokePositionManagersRequest {
  spoke: SpokeInput!
  includeInactive: Boolean
  pageSize: PageSize!
  cursor: Cursor
}

type SpokePositionManger {
  name: String!
  address: EvmAddress!
  active: Boolean!
}

input SpokeTokenInput {
  """The spoke address"""
  spoke: EvmAddress!

  """The token"""
  token: EvmAddress!

  """The chain id"""
  chainId: ChainId!
}

type SpokeUserPositionManager {
  name: String!
  address: EvmAddress!
  approvedOn: DateTime!
  active: Boolean!
}

input SpokeUserPositionManagersRequest {
  spoke: SpokeInput!
  user: EvmAddress!
  pageSize: PageSize!
  cursor: Cursor
}

input SpokesRequest @oneOf {
  """
  The hub address and chain id
  Get all the spokes which hubs are linked to a spoke reserve
  """
  hub: HubInput

  """
  The chain ids
  Get all the spokes which are on the list of chain ids
  """
  chainIds: [ChainId!]
}

input SupplyAPYHistoryRequest {
  spoke: SpokeInput!
  reserve: ReserveId!
  window: TimeWindow!
}

type SupplyActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  amount: Erc20Amount!
}

input SupplyPermitRequest {
  """The reserve"""
  reserve: ReserveInput!

  """The amount supplying"""
  amount: ReserveErc20AmountInput!

  """If you wish to enable collateral with it meaning you can borrow"""
  enableCollateral: Boolean! = true

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """
  If not supplied, this will use `sender` which is the normal route - you can only use on
  `onBehalfOf` if you're a position manager for that user
  """
  onBehalfOf: EvmAddress
}

input SupplyRequest {
  """The reserve"""
  reserve: ReserveInput!

  """The amount supplying"""
  amount: ReserveAmountInputWithPermit!

  """If you wish to enable collateral with it meaning you can borrow"""
  enableCollateral: Boolean! = true

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """
  If not supplied, this will use `sender` which is the normal route - you can only use on
  `onBehalfOf` if you're a position manager for that user
  """
  onBehalfOf: EvmAddress
}

type SwapActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  sellAmount: TokenAmount!
  buyAmount: TokenAmount!
  executedSellAmount: TokenAmount!
  executedBuyAmount: TokenAmount!
  createdAt: DateTime!
  fulfilledAt: DateTime!
  explorerLink: String!
}

type SwapApprovalRequired {
  approval: TransactionRequest!
  originalTransaction: SwapTransactionRequest!
}

type SwapByIntent {
  quote: SwapQuote!
  data: SwapByIntentTypedData!
}

input SwapByIntentInput {
  quoteId: SwapQuoteId!
  signature: Signature!
}

type SwapByIntentTypeDefinition {
  EIP712Domain: [TypeField!]!
  Order: [TypeField!]!
}

type SwapByIntentTypedData {
  types: SwapByIntentTypeDefinition!
  primaryType: String!
  domain: DomainData!
  message: JSON!
}

type SwapByIntentWithApprovalRequired {
  quote: SwapQuote!
  approval: TransactionRequest!
  data: SwapByIntentTypedData!
}

type SwapByTransaction {
  quote: SwapQuote!
}

type SwapCancelled {
  createdAt: DateTime!
  cancelledAt: DateTime
  explorerLink: String!
}

union SwapExecutionPlan = SwapTransactionRequest | SwapApprovalRequired | InsufficientBalanceError | SwapReceipt

type SwapExpired {
  createdAt: DateTime!
  expiredAt: DateTime!
  explorerLink: String!
}

type SwapFulfilled {
  txHash: String!
  sellAmount: TokenAmount!
  buyAmount: TokenAmount!
  executedSellAmount: TokenAmount!
  executedBuyAmount: TokenAmount!
  createdAt: DateTime!
  fulfilledAt: DateTime!
  explorerLink: String!
  refundTxHash: TxHash
}

scalar SwapId

enum SwapKind {
  BUY
  SELL
}

type SwapOpen {
  swapId: SwapId!
  createAt: DateTime!
  deadline: DateTime!
  explorerLink: String!
  sellAmount: TokenAmount!
  buyAmount: TokenAmount!
}

type SwapPendingSignature {
  createdAt: DateTime!
  deadline: DateTime!
  explorerLink: String!
}

type SwapQuote {
  quoteId: SwapQuoteId!
  suggestedSlippage: PercentValue!
  sellAmount: TokenAmount!
  buyAmount: TokenAmount!
  costs: SwapQuoteCosts!

  """Minimum received amount after all costs and slippage"""
  minimumReceived: TokenAmount!
}

type SwapQuoteCosts {
  """Network and provider costs"""
  networkCosts: TokenAmount!

  """Aave partner fee amount"""
  partnerFeeAmount: TokenAmount!
}

scalar SwapQuoteId

input SwapQuoteRequest {
  chainId: ChainId!
  buy: TokenInput!
  sell: TokenInput!
  amount: BigDecimal!
  kind: SwapKind
  from: EvmAddress!
  receiver: EvmAddress
}

type SwapReceipt {
  id: SwapId!
  createdAt: DateTime!
  explorerLink: String!
}

input SwapRequest @oneOf {
  intent: SwapByIntentInput
  transaction: SwapWithTransactionInput
}

union SwapStatus = SwapOpen | SwapPendingSignature | SwapCancelled | SwapExpired | SwapFulfilled

enum SwapStatusFilter {
  CANCELLED
  EXPIRED
  FULFILLED
  OPEN
  PENDING_SIGNATURE
}

input SwapStatusRequest {
  id: SwapId!
}

type SwapTransactionRequest {
  transaction: TransactionRequest!
  orderReceipt: SwapReceipt!
}

input SwapWithTransactionInput {
  quoteId: SwapQuoteId!
  permitSig: Signature

  """
  Whether the swap order creator is a smart contract wallet. If not provided, it will be inferred following the ERC-1271 standard.
  """
  isSenderSmartContractWallet: Boolean
}

input SwappableTokensRequest {
  query: SwappableTokensRequestQuery
}

input SwappableTokensRequestQuery {
  chainIds: [ChainId!]!
}

enum TimeWindow {
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  LAST_SIX_MONTHS
  LAST_YEAR
  ALL
}

union Token = NativeToken | Erc20Token

union TokenAmount = NativeAmount | Erc20Amount

type TokenInfo {
  """The token name"""
  name: String!

  """The token symbol"""
  symbol: String!

  """The token icon"""
  icon: String!

  """The token decimals"""
  decimals: Int!
}

input TokenInput @oneOf {
  """Native token"""
  native: AlwaysTrue

  """The erc20 address"""
  erc20: EvmAddress
}

type TransactionRequest {
  to: EvmAddress!
  from: EvmAddress!
  data: BlockchainData!
  value: BigInt!
  chainId: ChainId!
  operations: [OperationType!]
}

scalar TxHash

input TxHashInput {
  txHash: TxHash!
  chainId: ChainId!
}

type TypeDefinition {
  EIP712Domain: [TypeField!]!
  Permit: [TypeField!]!
}

type TypeField {
  name: String!
  type: String!
}

input UpdateUserDynamicConfigRequest {
  """The spoke"""
  spoke: SpokeInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """If not supplied, this will use `sender` which is the normal route"""
  onBehalfOf: EvmAddress
}

input UpdateUserRiskPremiumRequest {
  """The spoke"""
  spoke: SpokeInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """If not supplied, this will use `sender` which is the normal route"""
  onBehalfOf: EvmAddress
}

type UserBalance {
  """The token info"""
  info: TokenInfo!

  """The balances across chains it will be 1 item per chain"""
  balances: [TokenAmount!]!

  """The total amount summed across all balances"""
  totalAmount: DecimalValue!

  """The total fiat amount summed across all balances"""
  fiatAmount(currency: Currency! = USD): FiatAmount!

  """The supply APY dependent on what you pass in for the `metric`"""
  supplyApy(metric: ApyMetric! = HIGHEST): PercentValue!

  """The borrow APY dependent on what you pass in for the `metric`"""
  borrowApy(metric: ApyMetric! = HIGHEST): PercentValue!
}

input UserBalancesRequest {
  """The user to get the balance for"""
  user: EvmAddress!

  """The order by clause - defaults to the highest USD value"""
  orderBy: UserBalancesRequestOrderBy! = {balance: DESC}

  """The user balance filter"""
  filter: UserBalancesRequestFilter!

  """If you want to include 0 balances in the return list"""
  includeZeroBalances: Boolean! = false
}

input UserBalancesRequestFilter @oneOf {
  """List of chains"""
  chainIds: [ChainId!]

  """The balances for the underlyings attached to a hub"""
  hub: HubInput

  """The balances for the underlying attached to a spoke"""
  spoke: SpokeInput

  """The balances for the swappable tokens"""
  swappable: SwappableTokensRequestQuery
}

input UserBalancesRequestOrderBy @oneOf {
  """The name of the token"""
  name: OrderDirection

  """The balance of the token"""
  balance: OrderDirection
}

type UserBorrowItem {
  """The reserve borrowed from"""
  reserve: Reserve!

  """The amount borrowed"""
  amount: Erc20Amount!

  """The amount paid back of the borrow so far"""
  paid: Erc20Amount!
}

input UserBorrowsQueryRequest @oneOf {
  userSpoke: UserSpokeInput
  userPositionId: UserPositionId
}

input UserBorrowsRequest {
  query: UserBorrowsQueryRequest!
  orderBy: UserBorrowsRequestOrderBy! = {name: ASC}
}

input UserBorrowsRequestOrderBy @oneOf {
  name: OrderDirection
  balance: OrderDirection
  apy: OrderDirection
  paid: OrderDirection
}

input UserHistoryFilter @oneOf {
  spoke: SpokeInput
  chainIds: [ChainId!]
  txHash: TxHashInput
}

union UserHistoryItem = BorrowActivity | SupplyActivity | WithdrawActivity | RepayActivity | LiquidatedActivity | SwapActivity

input UserHistoryRequest {
  user: EvmAddress!
  activityTypes: [ActivityType!]! = [BORROW, SUPPLY, WITHDRAW, REPAY, SWAP, LIQUIDATED]
  filter: UserHistoryFilter!
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type UserPosition {
  """The user holding this position"""
  user: EvmAddress!

  """The user position ID"""
  id: UserPositionId!
  totalSupplied(currency: Currency! = USD): FiatAmountWithChange!

  """
  Total collateral which is the full some of the assets supplied which are enabled as collateral
  """
  totalCollateral(currency: Currency! = USD): FiatAmountWithChange!

  """Total debt which is the total amount borrowed plus the accrued premium"""
  totalDebt(currency: Currency! = USD): FiatAmountWithChange!

  """The net balance which is `total_supplied` - `borrows`"""
  netBalance(currency: Currency! = USD): FiatAmountWithChange!

  """The net collateral which is `totalCollateral` - `totalDebt`"""
  netCollateral(currency: Currency! = USD): FiatAmountWithChange!
  netApy: PercentValue!
  netSupplyApy: PercentValueWithChange!
  netBorrowApy: PercentValueWithChange!
  healthFactor: HealthFactorChange!
  betterRiskPremium: PercentValue
  riskPremium: PercentValue!
  netBalancePercentChange(window: TimeWindow! = LAST_DAY): PercentValue!
  spoke: Spoke!
}

scalar UserPositionId

input UserPositionRequest @oneOf {
  userSpoke: UserSpokeInput
  id: UserPositionId
}

input UserPositionsRequest {
  """The user to get the positions for"""
  user: EvmAddress!

  """The filter for the user position"""
  filter: UserPositionsRequestFilter!

  """The ordering for the positions"""
  orderBy: UserPositionsRequestOrderBy! = {created: ASC}
}

input UserPositionsRequestFilter @oneOf {
  tokens: [Erc20Input!]
  chainIds: [ChainId!]
}

input UserPositionsRequestOrderBy @oneOf {
  created: OrderDirection
  balance: OrderDirection
  netApy: OrderDirection
  healthFactor: OrderDirection
  netCollateral: OrderDirection
}

input UserSpokeInput {
  spoke: SpokeInput!
  user: EvmAddress!
}

type UserSummary {
  totalPositions: Int!

  """Net balance = supply - debt"""
  netBalance(currency: Currency! = USD): FiatAmountWithChange!

  """Total supply where is_collateral is true"""
  totalCollateral(currency: Currency! = USD): FiatAmount!

  """Total supplied across all positions"""
  totalSupplied(currency: Currency! = USD): FiatAmount!

  """Total debt across all positions"""
  totalDebt(currency: Currency! = USD): FiatAmount!

  """
  Net APY = (Σ (supplied_amount_i * supply_apy_i) - Σ (borrowed_amount_j * borrow_apy_j)) / (Σ supplied_amount_i)
  """
  netApy: PercentValue!

  """Interest earned (net fee earned)"""
  netFeeEarned: FiatAmount!

  """Lowest health factor across all positions"""
  lowestHealthFactor: BigDecimal
}

input UserSummaryFilter @oneOf {
  spoke: SpokeInput
  chainIds: [ChainId!]
}

type UserSummaryHistoryItem {
  healthFactor: BigDecimal
  date: DateTime!

  """The net balance"""
  netBalance(currency: Currency! = USD): FiatAmount!

  """The borrows"""
  borrows(currency: Currency! = USD): FiatAmount!

  """The supplies"""
  supplies(currency: Currency! = USD): FiatAmount!
}

input UserSummaryHistoryRequest {
  user: EvmAddress!
  filter: UserSummaryFilter
  window: TimeWindow!
}

input UserSummaryRequest {
  user: EvmAddress!
  filter: UserSummaryFilter
}

input UserSuppliesQueryRequest @oneOf {
  userSpoke: UserSpokeInput
  userPositionId: UserPositionId
}

input UserSuppliesRequest {
  query: UserSuppliesQueryRequest!
  orderBy: UserSuppliesRequestOrderBy! = {name: ASC}
}

input UserSuppliesRequestOrderBy @oneOf {
  name: OrderDirection
  balance: OrderDirection
  apy: OrderDirection
  earned: OrderDirection
}

type UserSupplyItem {
  """The reserve supplied to"""
  reserve: Reserve!

  """The amount of supplied shares"""
  amount: Erc20Amount!

  """The amount earned since supplying"""
  earned: Erc20Amount!

  """If this supply is used as collateral"""
  isCollateral: Boolean!
}

input UserSwapsRequest {
  chainId: ChainId!
  user: EvmAddress!
  filterBy: [SwapStatusFilter!]
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type WithdrawActivity {
  id: ID!
  timestamp: DateTime!
  txHash: TxHash!
  spoke: Spoke!
  reserve: ReserveInfo!
  amount: Erc20Amount!
}

input WithdrawRequest {
  """The reserve"""
  reserve: ReserveInput!

  """The amount withdrawing"""
  amount: WithdrawReserveAmountInput!

  """The user sending the transaction (normally the user's wallet address)"""
  sender: EvmAddress!

  """
  If not supplied, this will use `sender` which is the normal route - you can only use on
  `onBehalfOf` if you're a position manager for that user
  """
  onBehalfOf: EvmAddress
}

input WithdrawReserveAmountInput @oneOf {
  """The native amount"""
  native: AmountInput

  """The erc20 amount input"""
  erc20: AmountInput
}